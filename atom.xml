<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风之落木</title>
  
  <subtitle>寄君一曲，不问曲终人聚散。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-23T02:56:20.746Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王邦雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文件与目录管理</title>
    <link href="http://yoursite.com/2020/03/19/Linux%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/19/Linux%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-03-23T02:56:20.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常见的处理目录命令"><a href="#一、常见的处理目录命令" class="headerlink" title="一、常见的处理目录命令"></a>一、常见的处理目录命令</h1><p>ls: 列出目录<br>cd：切换目录<br>pwd：显示目前的目录<br> <a id="more"></a> mkdir：创建一个新的目录<br>rmdir：删除一个空的目录<br>cp: 复制文件或目录<br>rm: 移除文件或目录<br>mv: 移动文件与目录，或修改文件与目录的名称  </p><h2 id="1、ls-命令"><a href="#1、ls-命令" class="headerlink" title="1、ls 命令"></a>1、ls 命令</h2><p>语法：<code>ls 目录名称</code><br>[root@www ~]# ls -a 目录名称<br>[root@www ~]# ls -d 目录名称<br>[root@www ~]# ls -l 目录名称<br>选项与参数：<br>-a ：列出全部的文件，包括隐藏文件。<br>-d ：只列出目录本身。<br>-l ：长数据串列出，包含文件的属性与权限等等数据。</p><h2 id="2、cd-命令"><a href="#2、cd-命令" class="headerlink" title="2、cd 命令"></a>2、cd 命令</h2><p>用来切换工作目录的命令。<br>语法：<code>cd [相对路径或绝对路径]</code></p><ul><li>使用绝对路径切换到 test 目录<code>cd /root/test/</code></li><li>使用相对路径切换到 test 目录<code>cd ./runoob/</code></li><li>切换到家目录，即 /root 目录<code>cd ~</code></li><li>切换到当前的上一级目录，即 /root 的上一级目录<code>cd ..</code><h2 id="3、pwd-命令"><a href="#3、pwd-命令" class="headerlink" title="3、pwd 命令"></a>3、pwd 命令</h2>pwd 是显示当前所在目录的命令。<br>语法： <code>pwd [-P]</code><br>选项与参数：</li><li>P ：显示出完整的路径。<h2 id="4、mkdir-命令"><a href="#4、mkdir-命令" class="headerlink" title="4、mkdir 命令"></a>4、mkdir 命令</h2>使用 mkdir 命令创建一个新的目录<br>语法：<code>mkdir 目录名称[test]</code><br>选项与参数：</li><li>m ：配置文件的权限，直接配置。</li><li>p ：可以自行帮你创建多层目录。<h2 id="5、rmdir-命令"><a href="#5、rmdir-命令" class="headerlink" title="5、rmdir 命令"></a>5、rmdir 命令</h2>使用rmdir 命令删除空的目录<br>语法：<code>rmdir [-p] 目录名称</code><br>选项与参数：</li><li>p ：连同上一级『空的』目录也一起删除<br><code>注意：rmdir 只能删除空的目录，可以使用 rm 命令来删除非空目录。</code></li></ul><h2 id="6、cp-命令"><a href="#6、cp-命令" class="headerlink" title="6、cp 命令"></a>6、cp 命令</h2><p>使用cp命令复制文件或目录。<br>语法:<code>cp - [a d f i l p r s u] 来源档(source) 目标档(destination)</code><br>选项与参数：<br>-a：相当于 -pdr 。</p><p>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身。</p><p>-f：若目标文件已经存在且无法开启，则移除后再尝试一次。</p><p>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行。</p><p>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。</p><p>-p：连同文件的属性一起复制过去。</p><p>-r：递归持续复制，用于目录的复制。</p><p>-s：复制成为符号连结档 (symbolic link)。</p><p>-u：若 destination 比 source 旧才升级 destination。</p><h2 id="7、rm-命令"><a href="#7、rm-命令" class="headerlink" title="7、rm 命令"></a>7、rm 命令</h2><p>使用rm命令移除文件或目录<br>语法：<code>rm [-fir] 文件或目录</code><br>选项与参数：<br>-f ：忽略不存在的文件，不会出现警告信息。</p><p>-i ：互动模式，在删除前会询问使用者是否动作。<br>-r ：递归删除</p><h2 id="8、mv"><a href="#8、mv" class="headerlink" title="8、mv"></a>8、mv</h2><p>使用 mv 命令移动文件与目录。<br>语法：<code>mv [-fiu] source destination</code><br>选项与参数：</p><p>-f ：若目标文件已存在，不会询问而直接覆盖。</p><p>-i ：若目标文件已存在，就会询问是否覆盖。</p><p>-u ：若目标文件已存在，且 source 比较新，才会升级 (update)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、常见的处理目录命令&quot;&gt;&lt;a href=&quot;#一、常见的处理目录命令&quot; class=&quot;headerlink&quot; title=&quot;一、常见的处理目录命令&quot;&gt;&lt;/a&gt;一、常见的处理目录命令&lt;/h1&gt;&lt;p&gt;ls: 列出目录&lt;br&gt;cd：切换目录&lt;br&gt;pwd：显示目前的目录&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议</title>
    <link href="http://yoursite.com/2020/03/19/TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/03/19/TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-03-22T07:18:41.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP传输控制协议"><a href="#TCP传输控制协议" class="headerlink" title="TCP传输控制协议"></a>TCP传输控制协议</h1><p>TCP传输控制协议是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。 <a id="more"></a> </p><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h5 id="1、建立TCP连接（三次握手）"><a href="#1、建立TCP连接（三次握手）" class="headerlink" title="1、建立TCP连接（三次握手）"></a>1、建立TCP连接（三次握手）</h5><p>第一次握手：客户端发送TCP报文到服务器，等待服务器确认。<br>第二次握手：服务器端接收客户端发来的报文并确认，同时自己也发送一个SYN包给客户端，询问客户端是否准备好进行数据通讯。<br>第三次握手： 客户端收到服务器的SYN+ACK包，并回应服务端一个ACK报文。</p><h5 id="2、终止TCP连接（四次挥手）"><a href="#2、终止TCP连接（四次挥手）" class="headerlink" title="2、终止TCP连接（四次挥手）"></a>2、终止TCP连接（四次挥手）</h5><p>第一次挥手：客户端发出连接释放报文，并且停止客户端到服务器的数据传送。<br>第二次挥手：服务器收到连接释放报文，发出确认报文。<br>第三次挥手：服务器发送一个FIN给客户端，用来关闭与客户端的数据传送。<br>第四次挥手：客户段收到FIN后发回一个ACK报文给服务器，完成四次挥手。</p><h5 id="为什么连接时是三次握手，释放时却是四次握手？"><a href="#为什么连接时是三次握手，释放时却是四次握手？" class="headerlink" title="为什么连接时是三次握手，释放时却是四次握手？"></a>为什么连接时是三次握手，释放时却是四次握手？</h5><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><p>TCP还设有一个保活计时器。服务器每收到一次客户端的请求后都会重新复位这个计时器，若没有收到客户端的任何数据，服务器就会发送一个探测报文段。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP：提供的是面向连接的、传输效率低，可靠性强<br>UDP：提供的是非面向连接的、适用于传输可靠性要求不高，数据量小的数据</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP传输控制协议&quot;&gt;&lt;a href=&quot;#TCP传输控制协议&quot; class=&quot;headerlink&quot; title=&quot;TCP传输控制协议&quot;&gt;&lt;/a&gt;TCP传输控制协议&lt;/h1&gt;&lt;p&gt;TCP传输控制协议是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux vim显示行号的设置方法</title>
    <link href="http://yoursite.com/2020/03/18/Linux%20vim%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/18/Linux%20vim%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2020-03-22T02:05:41.556Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，vim打开文件时不提示行号。<br>临时显示行号：<code>在vim模式下输入 set nu 命令。</code><br>关闭当前打开的vim后就失效。<a id="more"></a><br>如果想每次打开vim都显示行号，则需要修改其配置文件，用户的配置文件放在用户主目录下以 <code>.vimrc</code> 命名。<br>修改配置文件：<br>输入命令：vim   ~/.vimrc，打开文件后，添加 set nu，保存退出，再次用vim打开文件时就可以显示行号了。</p><p>取消显示行号：<code>在vim命令行模式下输入set nonu</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认情况下，vim打开文件时不提示行号。&lt;br&gt;临时显示行号：&lt;code&gt;在vim模式下输入 set nu 命令。&lt;/code&gt;&lt;br&gt;关闭当前打开的vim后就失效。
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>功能测试</title>
    <link href="http://yoursite.com/2020/03/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/03/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2020-03-22T07:18:55.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="功能测试的概念"><a href="#功能测试的概念" class="headerlink" title="功能测试的概念"></a>功能测试的概念</h3><p>功能测试就是对产品的各功能进行验证，根据功能测试用例逐项测试，检查产品是否达到用户要求的功能；只需要考虑它的功能点不需要考虑软件的内部结构及代码等。<a id="more"></a> </p><h6 id="1-1图形测试"><a href="#1-1图形测试" class="headerlink" title="1.1图形测试"></a>1.1图形测试</h6><p>包括图片、动画、边框、颜色、字体、背景、按钮等。<br>其中要考虑以下几个重点：<br>（1）图片要有明确的用途；图片尺寸尽量小，格式一般采用JPG/GIF。<br>（2）页面整体风格是否和系统的用途一致。<br>（3）背景颜色、字体搭配是否合理。</p><h6 id="1-2表单测试"><a href="#1-2表单测试" class="headerlink" title="1.2表单测试"></a>1.2表单测试</h6><p>当用户在web应用系统上向服务器提交信息时，就需要使用表单操作，例如用户注册，登录，信息变更等。在该情况下，我们必须测试提交信息的完整性，以检验提交给服务器的数据的正确性。</p><h6 id="1-3内容测试"><a href="#1-3内容测试" class="headerlink" title="1.3内容测试"></a>1.3内容测试</h6><p>主要用来检测web系统提供信息的准确性、相关性。如：信息的准确性，拼写是否有误；价格，文字描述是否有误；信息的相关性，如相关文章列表，视频列表等。</p><h6 id="1-4链接测试"><a href="#1-4链接测试" class="headerlink" title="1.4链接测试"></a>1.4链接测试</h6><p> 链接主要用于页面之间切换跳转，指导用户去一些不知道地址的页面的主要手段，链接测试一般关注三点：<br>（1）链接是否按照既定指示那样，确实链接到了该链接的界面。<br>（2）测试该链接所链接的页面是否真的存在。<br>（3）保证系统中没有单独存在的页面。</p><h6 id="1-5导航测试"><a href="#1-5导航测试" class="headerlink" title="1.5导航测试"></a>1.5导航测试</h6><p>导航测试就是在不同的页面跳转之间，通过按钮，对话框，列表以及窗口等因素，去判断一个应用系统是否易于导航；是否直观；站点是否需要站内地图或者搜索引擎等其他帮助；web系统导航的另外一个重点就是页面结构、导航、菜单、风格等是否一致。确保用户可以凭借简单的判断就可以找到自己想要的内容。</p><h6 id="1-6整体界面测试"><a href="#1-6整体界面测试" class="headerlink" title="1.6整体界面测试"></a>1.6整体界面测试</h6><p>整体界面测试就是测试用户浏览时是否感觉舒适。一般做一个类似问卷调查的形式，来判定用户的反馈信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;功能测试的概念&quot;&gt;&lt;a href=&quot;#功能测试的概念&quot; class=&quot;headerlink&quot; title=&quot;功能测试的概念&quot;&gt;&lt;/a&gt;功能测试的概念&lt;/h3&gt;&lt;p&gt;功能测试就是对产品的各功能进行验证，根据功能测试用例逐项测试，检查产品是否达到用户要求的功能；只需要考虑它的功能点不需要考虑软件的内部结构及代码等。
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL 数据库基础知识</title>
    <link href="http://yoursite.com/2020/03/17/SQL%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/03/17/SQL%20%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-16T16:00:00.000Z</published>
    <updated>2020-03-22T02:04:55.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、SQL-SELECT-语句"><a href="#1、SQL-SELECT-语句" class="headerlink" title="1、SQL SELECT 语句"></a>1、SQL SELECT 语句</h1><p>SELECT 语句用于从数据库中选取数据，结果被存储在一个结果表中。<br>语法：<code>SELECT 列名称 FROM 表名;</code>与<code>与SELECT * FROM 表名;</code>  <a id="more"></a> </p><h1 id="2、SQL-SELECT-DISTINCT-语句"><a href="#2、SQL-SELECT-DISTINCT-语句" class="headerlink" title="2、SQL SELECT DISTINCT 语句"></a>2、SQL SELECT DISTINCT 语句</h1><p>SELECT DISTINCT 语句用于返回唯一不同的值。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名称 FROM 表名;</span><br></pre></td></tr></table></figure><h1 id="3、SQL-WHERE-子句"><a href="#3、SQL-WHERE-子句" class="headerlink" title="3、SQL WHERE 子句"></a>3、SQL WHERE 子句</h1><p>WHERE 子句用于提取那些满足指定条件的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">SELECT 列名 FROM 表名</span><br><span class="line">WHERE 列名 operator value;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例：从 &quot;test&quot; 表中选取地名为 &quot;SH&quot; 的所有网站</span><br><span class="line">SELECT * FROM test WHERE place&#x3D;&#39;SH&#39;;</span><br></pre></td></tr></table></figure><p>SQL 使用单引号来环绕文本值，如果是数值字段，不使用引号。<br>如：<code>SELECT * FROM test WHERE value=1;</code><br>WHERE 子句中的运算符<br>运算符     | 描述<br>——– | —–<br>=  | 等于<br>&lt;&gt;或！=  | 不等于</p><blockquote><p> | 大于<br>&lt;  | 小于<br>=  | 大于等于<br>&lt;=  | 小于等于<br>LIKE  | 搜索某种模式<br>BETWEEN | 在某个范围内<br>IN    | 指定针对某个列的多个可能值</p></blockquote><h1 id="4、SQL-AND-amp-OR-运算符"><a href="#4、SQL-AND-amp-OR-运算符" class="headerlink" title="4、SQL AND &amp; OR 运算符"></a>4、SQL AND &amp; OR 运算符</h1><p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p><ul><li>若第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</li><li>若第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</li></ul><p>把 AND 和 OR 结合起来，使用圆括号来组成复杂的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">SELECT * FROM test</span><br><span class="line">WHERE id &gt; 8</span><br><span class="line">AND (place&#x3D;&#39;HC&#39; OR place&#x3D;&#39;CN&#39;);</span><br></pre></td></tr></table></figure><h1 id="5、SQL-ORDER-BY-关键字"><a href="#5、SQL-ORDER-BY-关键字" class="headerlink" title="5、SQL ORDER BY 关键字"></a>5、SQL ORDER BY 关键字</h1><p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。<br>ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，可以使用 DESC 关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">ORDER BY 列名 ASC|DESC;</span><br></pre></td></tr></table></figure><p>ORDER BY 多列时：<br>order by A,B        这个时候都是默认按升序排列<br>order by A desc,B   这个时候 A 降序，B 升序排列<br>order by A ,B desc  这个时候 A 升序，B 降序排列<br><code>即 desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序。</code></p><h1 id="6、SQL-INSERT-INTO-语句"><a href="#6、SQL-INSERT-INTO-语句" class="headerlink" title="6、SQL INSERT INTO 语句"></a>6、SQL INSERT INTO 语句</h1><p>INSERT INTO 语句用于向表中插入新记录。<br>INSERT INTO 语句可以有两种编写形式。</p><ul><li>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名</span><br><span class="line">VALUES (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><ul><li>第二种形式需要指定列名及被插入的值：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (列名1,列名2,...)</span><br><span class="line">VALUES (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p><code>insert into select 和 select into from 的区别</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into scorebak select * from socre where neza&#x3D;&#39;neza&#39;   插入一行，要求表scorebak 必须存在</span><br><span class="line">select *  into scorebak from score  where neza&#x3D;&#39;neza&#39;  插入一行，要求表scorebak 不存在</span><br></pre></td></tr></table></figure><h1 id="7、SQL-UPDATE-语句"><a href="#7、SQL-UPDATE-语句" class="headerlink" title="7、SQL UPDATE 语句"></a>7、SQL UPDATE 语句</h1><p>UPDATE 语句用于更新表中已存在的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">UPDATE 表名</span><br><span class="line">SET 列名1&#x3D;value1,列名2&#x3D;value2,...</span><br><span class="line">WHERE 列名&#x3D;value;</span><br></pre></td></tr></table></figure><p><code>慎重执行没有 WHERE 子句的 UPDATE</code><br>在 MySQL 中可以通过设置 sql_safe_updates 这个自带的参数来解决，当该参数开启的情况下，你必须在update 语句后携带 where 条件，否则就会报错。<br>set sql_safe_updates=1; 表示开启该参数</p><h1 id="8、SQL-DELETE-语句"><a href="#8、SQL-DELETE-语句" class="headerlink" title="8、SQL DELETE 语句"></a>8、SQL DELETE 语句</h1><p>DELETE 语句用于删除表中的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">DELETE FROM 表名</span><br><span class="line">WHERE 列名&#x3D;value;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line">DELETE FROM test</span><br><span class="line">WHERE name&#x3D;&#39;百度&#39; AND place&#x3D;&#39;SH&#39;;</span><br></pre></td></tr></table></figure><ul><li>删除所有数据<br>可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名; 或 DELETE * FROM 表名;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL关于删除的三个语句：DROP、TRUNCATE、 DELETE 的区别。</span><br><span class="line">相同点：drop、delete、truncate 都是删除表的内容。</span><br><span class="line">不同点：</span><br><span class="line"> delete：删除表的内容，表的结构还存在，不释放空间，可以回滚恢复；</span><br><span class="line"> drop：删除表内容和结构，释放空间，没有备份表之前要慎用；</span><br><span class="line"> truncate：删除表的内容，表的结构存在，可以释放空间,没有备份表之前要慎用；</span><br><span class="line">执行速度：</span><br><span class="line">drop &gt; truncate &gt; delete</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、SQL-SELECT-语句&quot;&gt;&lt;a href=&quot;#1、SQL-SELECT-语句&quot; class=&quot;headerlink&quot; title=&quot;1、SQL SELECT 语句&quot;&gt;&lt;/a&gt;1、SQL SELECT 语句&lt;/h1&gt;&lt;p&gt;SELECT 语句用于从数据库中选取数据，结果被存储在一个结果表中。&lt;br&gt;语法：&lt;code&gt;SELECT 列名称 FROM 表名;&lt;/code&gt;与&lt;code&gt;与SELECT * FROM 表名;&lt;/code&gt;
    
    </summary>
    
    
    
      <category term="SQL数据库" scheme="http://yoursite.com/tags/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>软件测试理论基础</title>
    <link href="http://yoursite.com/2020/03/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/03/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-15T16:00:00.000Z</published>
    <updated>2020-03-22T02:03:26.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、软件测试概念"><a href="#一、软件测试概念" class="headerlink" title="一、软件测试概念"></a>一、软件测试概念</h1><p> 通过手工或工具对“被测对象”进行测试操作，从而验证实际与预期结果之间是否存在差异。<a id="more"></a> </p><h1 id="二、软件测试原则"><a href="#二、软件测试原则" class="headerlink" title="二、软件测试原则"></a>二、软件测试原则</h1><p>1、测试证明软件存在缺陷。<br>2、不能执行穷尽测试。<br>3、缺陷存在群集现象，对于软件功能来说，核心功能占20%，非核心是80%，集中测试20%的核心功能发现缺陷的几率高。<br>4、某些测试需要依赖特殊的环境。<br>5、尽可能早的开展测试。<br>6、杀虫剂现象：同样的一个测试用例不能重复的执行多次。<br>7、不存在缺陷谬论。</p><h1 id="三、测试级别"><a href="#三、测试级别" class="headerlink" title="三、测试级别"></a>三、测试级别</h1><p>软件开发都会依据相应的开发模型，测试级别指的就是在这个模型当中我们认为定义的开发步骤。<br>1、单元测试：指的是组成软件最小的底层代码结构，一般都是类、函数、组件等。<br>2、集成测试（接口测试）：将多个单元模块组合在一起，验证它们之间沟通的桥梁是否能正常工作。<br>3、系统测试：由测试人员充当用户然后对软件的功能主体进行测试。</p><h1 id="四、系统测试分类"><a href="#四、系统测试分类" class="headerlink" title="四、系统测试分类"></a>四、系统测试分类</h1><p>1、功能测试：验证当前软件主体功能是否可用。<br>2、兼容性测试：验证当前软件在不同的环境下是否还可以使用。<br>3、安全性测试：验证软件是否只是能授权用户提供功能使用。<br>4、性能测试：相对于当前软件消耗的资源，它的产出能力。</p><h1 id="五、软件测试流程"><a href="#五、软件测试流程" class="headerlink" title="五、软件测试流程"></a>五、软件测试流程</h1><p>1、需求分析</p><ul><li>核心目的：弄清楚要测啥。</li><li>需求来源：需求规格说明书、API文档、同行竞品分析等。</li></ul><p>2、设计用例  </p><ul><li>用例就是用户为了测试软件的某个功能而执行的操作过程。</li><li>设计用例的方法有：等价类、边界值、因果图等。</li></ul><p>3、评审用例</p><ul><li>对当前的用例进行添加或删除。</li></ul><p>4、配置环境</p><ul><li>环境分类：操作系统、服务器软件、数据库、软件底层代码的执行环境。</li></ul><p>5、执行用例</p><ul><li>执行前先做冒烟测试，其核心是快速的对当前软件的核心功能进行验证。</li></ul><p>6、回归测试及缺陷跟踪</p><ul><li>目的是检验已经被发现的缺陷有没有被正确的修改和修改过程中有没有引发新的缺陷。软件在测试或者其他活动中发现的缺陷经过修改后，都要进行回归测试的验证。</li></ul><p>7、输出测试报告</p><ul><li>将当前的测试过程中产生的数据进行可视化的输出。</li></ul><p>8、测试结束</p><ul><li>把测试过程的文档进行整理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、软件测试概念&quot;&gt;&lt;a href=&quot;#一、软件测试概念&quot; class=&quot;headerlink&quot; title=&quot;一、软件测试概念&quot;&gt;&lt;/a&gt;一、软件测试概念&lt;/h1&gt;&lt;p&gt; 通过手工或工具对“被测对象”进行测试操作，从而验证实际与预期结果之间是否存在差异。
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>VBScript函数</title>
    <link href="http://yoursite.com/2020/02/15/VBScript%20%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/15/VBScript%20%E5%87%BD%E6%95%B0/</id>
    <published>2020-02-14T16:00:00.000Z</published>
    <updated>2020-03-22T07:54:18.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="String-函数"><a href="#String-函数" class="headerlink" title="String 函数"></a>String 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">InStr返回字符串在另一字符串中首次出现的位置。检索从字符串的第一个字符开始 &lt;!-- more --&gt;</span><br><span class="line"> </span><br><span class="line">InStrRev返回字符串在另一字符串中首次出现的位置。检索从字符串的最末字符开始</span><br><span class="line">LCase把指定字符串转换为小写</span><br><span class="line">Left从字符串的左侧返回指定数目的字符</span><br><span class="line">Len返回字符串中的字符数目</span><br><span class="line">LTrim删除字符串左侧的空格</span><br><span class="line">RTrim删除字符串右侧的空格</span><br><span class="line">Trim删除字符串左侧和右侧的空格</span><br><span class="line">Mid从字符串返回指定数目的字符</span><br><span class="line">Replace使用另外一个字符串替换字符串的指定部分指定的次数</span><br><span class="line">Right返回从字符串右侧开始指定数目的字符</span><br><span class="line">Space返回由指定数目的空格组成的字符串</span><br><span class="line">StrComp比较两个字符串，返回代表比较结果的一个值</span><br><span class="line">String返回包含指定长度的重复字符的字符串</span><br><span class="line">StrReverse反转字符串</span><br><span class="line">UCase把指定的字符串转换为大写</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Date-和-Time-函数"><a href="#Date-和-Time-函数" class="headerlink" title="Date 和 Time 函数"></a>Date 和 Time 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CDate       把一个有效的日期或时间表达式转换为日期类型</span><br><span class="line">Date       返回当前的系统日期</span><br><span class="line">DateAdd       返回已添加指定时间间隔的日期</span><br><span class="line">DateDiff       返回两个日期之间的时间间隔数</span><br><span class="line">DatePart       返回给定日期的指定部分</span><br><span class="line">DateSerial     返回日期的指定年、月、日</span><br><span class="line">DateValue      返回日期</span><br><span class="line">Day           返回代表一月中一天的数字</span><br><span class="line">FormatDateTime 返回以日期或时间格式化的表达式</span><br><span class="line">Hour       返回可代表一天中的小时的数字 </span><br><span class="line">IsDate       返回可指示计算表达式能否转换为日期的布尔值</span><br><span class="line">Minute       返回一个数字，代表小时的分钟 </span><br><span class="line">Month       返回一个数字，代表年的月份</span><br><span class="line">MonthName   返回指定月份的名称</span><br><span class="line">Now           返回当前的系统日期和时间</span><br><span class="line">Second       返回一个数字，代表分钟的秒</span><br><span class="line">Time       返回当前的系统时间</span><br><span class="line">Timer       返回自 12:00 AM 以来的秒数</span><br><span class="line">TimeSerial   返回特定小时、分钟和秒的时间</span><br><span class="line">TimeValue   返回时间</span><br><span class="line">Weekday       返回一个数字，代表星期的一天</span><br><span class="line">WeekdayName   返回星期中指定的一天的星期名</span><br><span class="line">Year       返回一个代表年份的数字</span><br></pre></td></tr></table></figure><h3 id="Format-函数"><a href="#Format-函数" class="headerlink" title="Format 函数"></a>Format 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FormatCurrency返回作为货币值进行格式化的表达式</span><br><span class="line">FormatDateTime返回作为日期或时间进行格式化的表达式</span><br><span class="line">FormatNumber返回作为数字进行格式化的表达式</span><br><span class="line">FormatPercent返回作为百分数进行格式化的表达式</span><br></pre></td></tr></table></figure><h3 id="Conversion-函数"><a href="#Conversion-函数" class="headerlink" title="Conversion 函数"></a>Conversion 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Asc           把字符串中的首字母转换为 ANSI 字符代码</span><br><span class="line">CBool       把表达式转换为布尔类型</span><br><span class="line">CByte        把表达式转换为 Byte 类型</span><br><span class="line">CCur       把表达式转换为货币（Currency）类型</span><br><span class="line">CDate       把有效的日期和时间表达式转换为 Date 类型</span><br><span class="line">CDbl       把表达式转换为 Double 类型</span><br><span class="line">Chr           把指定的 ANSI 字符代码转换为字符</span><br><span class="line">CInt       把表达式转换为 Int 类型</span><br><span class="line">CLng       把表达式转换为 Long 类型</span><br><span class="line">CSng       把表达式转换为 Single 类型</span><br><span class="line">CStr       把表达式转换为子类型 String 的 variant </span><br><span class="line">Hex           返回指定数字的十六进制值</span><br><span class="line">Oct           返回指定数字的八进制值</span><br></pre></td></tr></table></figure><h3 id="Array-函数"><a href="#Array-函数" class="headerlink" title="Array 函数"></a>Array 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array返回一个包含数组的变量</span><br><span class="line">Filter返回下标从零开始的数组，其中包含基于特定过滤条件的字符串数组的子集</span><br><span class="line">IsArray返回一个布尔值，可指示指定的变量是否是数组</span><br><span class="line">Join返回一个由数组中若干子字符串组成的字符串</span><br><span class="line">LBound返回指定数组维数的最小下标</span><br><span class="line">Split返回下标从0开始的一维数组，包含指定数目的子字符串</span><br><span class="line">UBound返回指定数组维数的最大下标</span><br></pre></td></tr></table></figure><h3 id="Math-函数"><a href="#Math-函数" class="headerlink" title="Math 函数"></a>Math 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Abs            返回指定数字的绝对值</span><br><span class="line">Atn            返回指定数字的反正切</span><br><span class="line">Cos            返回指定数字或角度的余弦</span><br><span class="line">Exp返回 e的幂次方</span><br><span class="line">Hex返回指定数字的十六进制值</span><br><span class="line">Int返回指定数字的整数部分</span><br><span class="line">Fix返回指定数字的整数部分</span><br><span class="line">Log返回指定数字的自然对数</span><br><span class="line">Oct返回指定数字的余弦值</span><br><span class="line">Rnd返回小于1但大于或等于0的一个随机数</span><br><span class="line">Sgn返回可指示指定的数字的符号的一个整数</span><br><span class="line">Sin返回指定数字或角度的正弦</span><br><span class="line">Sqr返回指定数字的平方根</span><br><span class="line">Tan返回指定数字或角度的正切</span><br></pre></td></tr></table></figure><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CreateObject创建指定类型对象。</span><br><span class="line">Eval计算表达式，并返回结果。</span><br><span class="line">GetLocale返回当前区域设置 ID 值。</span><br><span class="line">GetObject返回对文件中 automation 对象的引用。</span><br><span class="line">GetRef允许把 VBScript 子程序连接到页面上的一个 DHTML 事件。</span><br><span class="line">InputBox可显示对话框，用户可在其中输入文本，并&#x2F;或点击按钮，然后返回结果。</span><br><span class="line">IsEmpty返回一个布尔值，指示指定的变量是否已被初始化。</span><br><span class="line">IsNull返回一个布尔值，指示指定的变量是否包含无效数据 (Null)。</span><br><span class="line">IsNumeric返回一个布尔值，指示指定的表达式是否可作为数字来计算。</span><br><span class="line">IsObject返回一个布尔值，指示指定的表达式是否是一个 automation 对象。</span><br><span class="line">LoadPicture返回一个图片对象。仅用于32位平台。</span><br><span class="line">MsgBox显示消息框，等待用户点击按钮，并返回指示用户点击了哪个按钮的值。</span><br><span class="line">RGB返回一个表示 RGB 颜色值的数字。</span><br><span class="line">Round对数进行四舍五入。</span><br><span class="line">ScriptEngine返回使用中的脚本语言。</span><br><span class="line">ScriptEngineBuildVersion返回使用中的脚本引擎版本号。</span><br><span class="line">ScriptEngineMajorVersion返回使用中的脚本引擎的主版本号。</span><br><span class="line">ScriptEngineMinorVersion返回使用中的脚本引擎的次版本号。</span><br><span class="line">SetLocale设置地区 ID ，并返回之前的地区 ID。</span><br><span class="line">TypeName返回指定变量的子类型。</span><br><span class="line">VarType返回指示变量子类型的值。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;String-函数&quot;&gt;&lt;a href=&quot;#String-函数&quot; class=&quot;headerlink&quot; title=&quot;String 函数&quot;&gt;&lt;/a&gt;String 函数&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;InStr			返回字符串在另一字符串中首次出现的位置。检索从字符串的第一个字符开始 &amp;lt;!-- more --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;InStrRev		返回字符串在另一字符串中首次出现的位置。检索从字符串的最末字符开始&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LCase			把指定字符串转换为小写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Left			从字符串的左侧返回指定数目的字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Len				返回字符串中的字符数目&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LTrim			删除字符串左侧的空格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RTrim			删除字符串右侧的空格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Trim			删除字符串左侧和右侧的空格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mid				从字符串返回指定数目的字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Replace			使用另外一个字符串替换字符串的指定部分指定的次数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Right			返回从字符串右侧开始指定数目的字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Space			返回由指定数目的空格组成的字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StrComp			比较两个字符串，返回代表比较结果的一个值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String			返回包含指定长度的重复字符的字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StrReverse		反转字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UCase			把指定的字符串转换为大写&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>单片机程序(C语言编写)的编译与下载</title>
    <link href="http://yoursite.com/2020/02/05/%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F(C%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99)%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2020/02/05/%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F(C%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99)%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-02-04T16:00:00.000Z</published>
    <updated>2020-03-24T05:09:26.242Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-单片机程序的编译过程"><a href="#1-单片机程序的编译过程" class="headerlink" title="1. 单片机程序的编译过程"></a>1. 单片机程序的编译过程</h5><p>程序编好后，需要对程序进行编译，生成可以下载到单片机里的文件。在编译之前，需要先勾选一个选项，<code>Project--&gt;Options for Target „Target1‟...</code>。在弹出的对话框中，点击 <code>Output 选项页</code>，勾选其中的<code>“Create HEX File”</code>复选框，然后点 OK。设置好后，点击<code>“Project--&gt;rebuild all target files”</code>进行编译。编译完成后，在 Keil 下方的 Output 窗口会出现相应的提示，当提示<code>“0 Error(s), 0 warning(s)”</code>表示我们的程序没有错误和警告，就会出现<code>“creating hex file from ”...</code>，意思是从当前工程生成了一个 HEX 文件，要下载到单片机上的就是该HEX 文件。</p><a id="more"></a><p>程序案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;  //包含特殊功能寄存器定义的头文件</span></span></span><br><span class="line">sbit LED = P0^<span class="number">0</span>;  <span class="comment">//位地址声明，注意：sbit 必须小写、P 大写！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//任何一个 C 程序都必须有且仅有一个 main 函数,void 是函数的返回值类型</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">        LED = <span class="number">0</span>; <span class="comment">//分号表示一条语句结束</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-单片机程序的下载过程"><a href="#2-单片机程序的下载过程" class="headerlink" title="2. 单片机程序的下载过程"></a>2. 单片机程序的下载过程</h5><p>（1）把硬件连接好，把板子插到我们的电脑上，打开设备管理器查看所使用的是哪个 COM 口，找到<code>“USB-SERIAL CH340(COM5)”</code>这一项，最后的数字就是开发板目前所使用的 COM 端口号。<br>（2） STC 系列单片的下载软件——STC-ISP 步骤<br>第一步：选择单片机型号。<br>第二步：点击<code>“打开程序文件”</code>，找到建立工程的文件夹，找到<code>.hex 文件</code>，点击打开。<br>第三步：选择查到的 COM端口号，波特率使用默认的。<br>第四步：所有选项都使用默认设置。<br>第五步：先关闭板子上的电源开关，然后点击“Download/下载”按钮，等待软件提示你请上电后，再按下板子的电源开关，就可以将程序下载到单片机里边了。当软件显示“已加密”表示程序下载成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-单片机程序的编译过程&quot;&gt;&lt;a href=&quot;#1-单片机程序的编译过程&quot; class=&quot;headerlink&quot; title=&quot;1. 单片机程序的编译过程&quot;&gt;&lt;/a&gt;1. 单片机程序的编译过程&lt;/h5&gt;&lt;p&gt;程序编好后，需要对程序进行编译，生成可以下载到单片机里的文件。在编译之前，需要先勾选一个选项，&lt;code&gt;Project--&amp;gt;Options for Target „Target1‟...&lt;/code&gt;。在弹出的对话框中，点击 &lt;code&gt;Output 选项页&lt;/code&gt;，勾选其中的&lt;code&gt;“Create HEX File”&lt;/code&gt;复选框，然后点 OK。设置好后，点击&lt;code&gt;“Project--&amp;gt;rebuild all target files”&lt;/code&gt;进行编译。编译完成后，在 Keil 下方的 Output 窗口会出现相应的提示，当提示&lt;code&gt;“0 Error(s), 0 warning(s)”&lt;/code&gt;表示我们的程序没有错误和警告，就会出现&lt;code&gt;“creating hex file from ”...&lt;/code&gt;，意思是从当前工程生成了一个 HEX 文件，要下载到单片机上的就是该HEX 文件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="单片机" scheme="http://yoursite.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>单片机内部结构及其最小系统</title>
    <link href="http://yoursite.com/2020/02/04/51%E5%8D%95%E7%89%87%E6%9C%BASFR%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E4%BD%8D%E5%AE%9A%E4%B9%89/"/>
    <id>http://yoursite.com/2020/02/04/51%E5%8D%95%E7%89%87%E6%9C%BASFR%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E4%BD%8D%E5%AE%9A%E4%B9%89/</id>
    <published>2020-02-03T16:00:00.000Z</published>
    <updated>2020-03-24T09:26:02.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-sfr-P0-0x80"><a href="#1-sfr-P0-0x80" class="headerlink" title="1. sfr  P0 = 0x80;"></a>1. sfr  P0 = 0x80;</h3><p>sfr 关键字，是 51 单片机特有的，其作用是定义一个单片机特殊功能寄存器(special function register)。51 单片机内部有很多个小模块，每个模块都有 8 个控制开关。P0 是一个功能模块，sfr P0=0X80 定义特殊功能寄存器 P0，P0 的地址值为 0X80。通过设置 P0 内部这个模块的 8 个开关，来让单片机的 P0 这 8 个 IO 口输出高电平或低电平。51 单片机内部有很多寄存器，如果我们想使用的话须提前进行 sfr 声明。不过 Keil 软件已经把所有这些声明都预先写好并保存到一个专门的文件中去了，我们要用的话只需在文件开头添加一行<code>#include&lt;reg52.h&gt;</code>即可。</p><a id="more"></a> <h3 id="2-sbit-LED-P0-0"><a href="#2-sbit-LED-P0-0" class="headerlink" title="2. sbit  LED = P0^0;"></a>2. sbit  LED = P0^0;</h3><p>sbit是对 SFR 里的 8 个开关中的一个开关进行定义。经过该条语句后，以后只要在程序里写 LED，就代表了 P0.0 口，<code>P 必须大写</code>。</p><h5 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h5><p>晶振，也叫晶体振荡器。作用是为单片机系统提供基准时钟信号，单片机内部所有的工作都是以这个时钟信号为步调基准来进行工作的。STC89C52 单片机的 18 脚和 19 脚是晶振引脚，接一个 11.0592M 的晶振（它每秒钟振荡 11,059,200 次），外加两个 20pF 的电容，电容的作用是帮助晶振起振，并维持振荡信号的稳定。</p><h5 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h5><p>复位电路是一种用来使电路恢复到起始状态的电路设备。复位电路启动的手段有：上电复位、手动复位、程序自动复位。</p><ul><li>上电复位<br>上电复位是在给电路通电时马上进行复位操作。<br>停电导致单片机内部部分区域数据丢失，下次打开设备的时，能够使单片机能正常运行，单片机要进行一个内部的初始化过程，这个过程称为上电复位，上电复位保证单片机每次都从一个固定的相同的状态开始工作。</li><li>手动复位<br>手动复位是在必要时由手动操作。当程序运行时，如果遭受到意外干扰而导致程序死机，或者程序跑飞的时候，可以按下复位按键，让程序重新初始化重新运行，该过程称作手动复位。</li><li>程序自动复位<br>程序自动复位是根据程序或者电路运行的需要自动地进行。当程序死机或者跑飞的时，单片机有一套自动复位机制，如看门狗，如果程序长时间失去响应，单片机看门狗模块会自动复位重启单片机。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-sfr-P0-0x80&quot;&gt;&lt;a href=&quot;#1-sfr-P0-0x80&quot; class=&quot;headerlink&quot; title=&quot;1. sfr  P0 = 0x80;&quot;&gt;&lt;/a&gt;1. sfr  P0 = 0x80;&lt;/h3&gt;&lt;p&gt;sfr 关键字，是 51 单片机特有的，其作用是定义一个单片机特殊功能寄存器(special function register)。51 单片机内部有很多个小模块，每个模块都有 8 个控制开关。P0 是一个功能模块，sfr P0=0X80 定义特殊功能寄存器 P0，P0 的地址值为 0X80。通过设置 P0 内部这个模块的 8 个开关，来让单片机的 P0 这 8 个 IO 口输出高电平或低电平。51 单片机内部有很多寄存器，如果我们想使用的话须提前进行 sfr 声明。不过 Keil 软件已经把所有这些声明都预先写好并保存到一个专门的文件中去了，我们要用的话只需在文件开头添加一行&lt;code&gt;#include&amp;lt;reg52.h&amp;gt;&lt;/code&gt;即可。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="单片机" scheme="http://yoursite.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>单片机内部结构及其最小系统</title>
    <link href="http://yoursite.com/2020/02/03/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/02/03/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2020-03-24T04:33:01.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-单片机内部结构"><a href="#1-单片机内部结构" class="headerlink" title="1. 单片机内部结构"></a>1. 单片机内部结构</h3><h5 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h5><p>Flash是单片机的程序存储空间，Flash 的优点是可重复擦写、容量大以及成本低。对于单片机来说 Flash 最大的意义是断电后数据不丢失。</p><h5 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h5><p>RAM 是单片机的数据存储空间，用来存储程序运行过程中产生的和需要的数据。其优点是读写速度快、可无限次写入。</p><h5 id="SFR"><a href="#SFR" class="headerlink" title="SFR"></a>SFR</h5><p> SFR是单片机的特殊功能寄存器。单片机有很多功能，每个功能都会对应一个或多个 SFR，通过对 SFR 的读写来实现单片机的多种功能。</p><a id="more"></a><h3 id="2-单片机最小系统"><a href="#2-单片机最小系统" class="headerlink" title="2. 单片机最小系统"></a>2. 单片机最小系统</h3><p>单片机最小系统是指用最少的原件组成单片机可以工作的系统。单片机最小系统的三要素是电源、晶振、复位电路。</p><h5 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h5><p>目前主流单片机的电源有 5V 和 3.3V 两个标准。STC89C52单片机需要 5V 的供电系统，供电电路在 40 脚和 20 脚的位置上，40 脚接的是+5V，通常称为 VCC 或 VDD，代表的是电源正极，20 脚接的是 GND，代表的是电源的负极。+5V 和 GND 之间接一个电容，作用是隔离直流。</p><h5 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h5><p>晶振，也叫晶体振荡器。作用是为单片机系统提供基准时钟信号，单片机内部所有的工作都是以这个时钟信号为步调基准来进行工作的。STC89C52 单片机的 18 脚和 19 脚是晶振引脚，接一个 11.0592M 的晶振（它每秒钟振荡 11,059,200 次），外加两个 20pF 的电容，电容的作用是帮助晶振起振，并维持振荡信号的稳定。</p><h5 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h5><p>复位电路是一种用来使电路恢复到起始状态的电路设备。复位电路启动的手段有：上电复位、手动复位、程序自动复位。</p><ul><li>上电复位<br>上电复位是在给电路通电时马上进行复位操作。<br>停电导致单片机内部部分区域数据丢失，下次打开设备的时，能够使单片机能正常运行，单片机要进行一个内部的初始化过程，这个过程称为上电复位，上电复位保证单片机每次都从一个固定的相同的状态开始工作。</li><li>手动复位<br>手动复位是在必要时由手动操作。当程序运行时，如果遭受到意外干扰而导致程序死机，或者程序跑飞的时候，可以按下复位按键，让程序重新初始化重新运行，该过程称作手动复位。</li><li>程序自动复位<br>程序自动复位是根据程序或者电路运行的需要自动地进行。当程序死机或者跑飞的时，单片机有一套自动复位机制，如看门狗，如果程序长时间失去响应，单片机看门狗模块会自动复位重启单片机。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-单片机内部结构&quot;&gt;&lt;a href=&quot;#1-单片机内部结构&quot; class=&quot;headerlink&quot; title=&quot;1. 单片机内部结构&quot;&gt;&lt;/a&gt;1. 单片机内部结构&lt;/h3&gt;&lt;h5 id=&quot;Flash&quot;&gt;&lt;a href=&quot;#Flash&quot; class=&quot;headerlink&quot; title=&quot;Flash&quot;&gt;&lt;/a&gt;Flash&lt;/h5&gt;&lt;p&gt;Flash是单片机的程序存储空间，Flash 的优点是可重复擦写、容量大以及成本低。对于单片机来说 Flash 最大的意义是断电后数据不丢失。&lt;/p&gt;
&lt;h5 id=&quot;RAM&quot;&gt;&lt;a href=&quot;#RAM&quot; class=&quot;headerlink&quot; title=&quot;RAM&quot;&gt;&lt;/a&gt;RAM&lt;/h5&gt;&lt;p&gt;RAM 是单片机的数据存储空间，用来存储程序运行过程中产生的和需要的数据。其优点是读写速度快、可无限次写入。&lt;/p&gt;
&lt;h5 id=&quot;SFR&quot;&gt;&lt;a href=&quot;#SFR&quot; class=&quot;headerlink&quot; title=&quot;SFR&quot;&gt;&lt;/a&gt;SFR&lt;/h5&gt;&lt;p&gt; SFR是单片机的特殊功能寄存器。单片机有很多功能，每个功能都会对应一个或多个 SFR，通过对 SFR 的读写来实现单片机的多种功能。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="单片机" scheme="http://yoursite.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Keil 5 安装与使用</title>
    <link href="http://yoursite.com/2020/02/02/Keil%205%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/02/Keil%205%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-01T16:00:00.000Z</published>
    <updated>2020-03-24T04:53:19.016Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Keil-5-软件介绍"><a href="#1-Keil-5-软件介绍" class="headerlink" title="1. Keil 5 软件介绍"></a>1. Keil 5 软件介绍</h5><p>Keil C51是51系列兼容单片机C语言软件开发系统，与汇编相比，C语言在功能上、结构性、可读性、可维护性上有明显的优势，因而易学易用。Keil提供了包括C编译器、宏汇编、链接器、库管理和一个功能强大的仿真调试器等在内的完整开发方案，通过一个集成开发环境(μVision)将这些部分组合在一起。<a id="more"></a> 如果你使用C语言编程，那么Keil几乎就是你的不二之选，即使不使用C语言而仅用汇编语言编程，其方便易用的集成环境、强大的软件仿真调试工具也会令你事半功倍。</p><h5 id="2-Keil-5-安装步骤"><a href="#2-Keil-5-安装步骤" class="headerlink" title="2. Keil 5 安装步骤"></a>2. Keil 5 安装步骤</h5><ul><li>（1）下载好 Keil 安装源文件，双击安装文件，弹出安装的欢迎界面。</li><li>（2）点击“Next”按钮，弹出“License Agreement”对话框，在“I agree to all the terms of the preceding License Agreement”打勾。</li><li>（3）点击“Next”按钮，弹出“Folder Selection”对话框。设置安装路径，默认安装路径在“C:\Keil”文件夹下。点击“Browse…”按钮，可以修改安装路径。</li><li>（4）点击“Next”按钮，弹出“Customer Information”对话框，输入用户名、公司名称以及 E-mail 地址。</li><li>（5）单击“Next”，自动安装软件。</li><li>（6）安装完成后，弹出来安装完成对话框，去掉出现的几个选项。</li><li>（7）最后，点击“Finish”，安装完成。</li></ul><h5 id="3-使用-Keil-5-建立工程"><a href="#3-使用-Keil-5-建立工程" class="headerlink" title="3. 使用 Keil 5 建立工程"></a>3. 使用 Keil 5 建立工程</h5><p>（1）打开Keil 软件后，点击：Project–&gt;New uVision Project…，出现一个新建工程的界面。然后指定工程的路径，软件会自动添加扩展名.uvproj，点击保存即可。<br>（2）保存后会弹出一个对话框，选择单片机型号，选择 Intel  80/87C52 来替代STC89C52。<br>（3）点击 OK 后，会弹出一个对话框。每个工程都需要一段启动代码，如果点“否”编译器会自动处理这个问题。如果点“是”，这部分代码会提供给我们用户，我们就可以按需要自己去处理这部分代码。这样工程就建立好了。<br>（4）工程建好后，需要建立编写代码的文件，点击 File–&gt;New，新建一个文件，然后点 File–&gt;Save 保存文件，保存时文件命名：c语言后缀为<code>.c</code>，汇编语言的后缀为<code>.asm</code>。<br>（5）每做一个功能程序，必须要新建一个工程，一个工程代表单片机要实现的一个功能。但是一个工程，有时候我们可以把我们的程序分多个文件写，所以每写一个文件，我们都要添加到我们所建立的工程中去，鼠标右键点 Source Group 1，点 Add Files to Group„Source Group 1‟…，在弹出的对话框中，单击文件名并选中它，然后点 Add，然后单击 Close，关闭添加。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-Keil-5-软件介绍&quot;&gt;&lt;a href=&quot;#1-Keil-5-软件介绍&quot; class=&quot;headerlink&quot; title=&quot;1. Keil 5 软件介绍&quot;&gt;&lt;/a&gt;1. Keil 5 软件介绍&lt;/h5&gt;&lt;p&gt;Keil C51是51系列兼容单片机C语言软件开发系统，与汇编相比，C语言在功能上、结构性、可读性、可维护性上有明显的优势，因而易学易用。Keil提供了包括C编译器、宏汇编、链接器、库管理和一个功能强大的仿真调试器等在内的完整开发方案，通过一个集成开发环境(μVision)将这些部分组合在一起。
    
    </summary>
    
    
    
      <category term="单片机" scheme="http://yoursite.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2020/02/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/02/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-01-31T16:00:00.000Z</published>
    <updated>2020-03-23T06:49:16.050Z</updated>
    
    <content type="html"><![CDATA[<p>简单选择排序方法：将序列每次折半划分；将划分后的序列段两两合并后排序。<br>空间复杂度：O(n)；<br>时间复杂度：O(nlog2n)；<br>例子：有一个序列 5，9，6，4，2，8，3，7。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">排序前：  <span class="number">5</span>，<span class="number">9</span>，<span class="number">6</span>，<span class="number">4</span>，<span class="number">2</span>，<span class="number">8</span>，<span class="number">3</span>，<span class="number">7</span>。</span><br><span class="line">第<span class="number">1</span>趟：（<span class="number">2</span>，<span class="number">9</span>），（<span class="number">6</span>，<span class="number">4</span>），（<span class="number">5</span>，<span class="number">8</span>） ，（<span class="number">3</span>，<span class="number">7</span>）。</span><br><span class="line">第<span class="number">2</span>趟：（<span class="number">2</span>，<span class="number">9</span>，<span class="number">4</span>，<span class="number">6</span>），（<span class="number">5</span>，<span class="number">8</span> ，<span class="number">3</span>，<span class="number">7</span>）。</span><br><span class="line">第<span class="number">3</span>趟：（<span class="number">2</span>，<span class="number">4</span>，<span class="number">6</span>，<span class="number">9</span>），（<span class="number">5</span>，<span class="number">3</span> ，<span class="number">7</span>，<span class="number">8</span>）。</span><br><span class="line">第<span class="number">4</span>趟：（<span class="number">2</span>，<span class="number">4</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">5</span>，<span class="number">3</span> ，<span class="number">7</span>，<span class="number">8</span>）。</span><br><span class="line">第<span class="number">5</span>趟：<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span>。</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=low;</span><br><span class="line"><span class="keyword">for</span>(i=low;i&lt;=high;i++)<span class="comment">//复制到b</span></span><br><span class="line">b[i]=a[i];</span><br><span class="line"><span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>;i&lt;=mid&amp;&amp;j&lt;=high;k++)</span><br><span class="line"><span class="keyword">if</span>(b[i]&lt;=b[j])</span><br><span class="line">a[k]=b[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a[k]=b[j++];</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">a[k++]=b[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)</span><br><span class="line">a[k++]=b[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">if</span>(low&lt;high)</span><br><span class="line">&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">MergeSort(a,b,low,mid);</span><br><span class="line">MergeSort(a,b,mid+<span class="number">1</span>,high);</span><br><span class="line">Merge(a,b,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单选择排序方法：将序列每次折半划分；将划分后的序列段两两合并后排序。&lt;br&gt;空间复杂度：O(n)；&lt;br&gt;时间复杂度：O(nlog2n)；&lt;br&gt;例子：有一个序列 5，9，6，4，2，8，3，7。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>简单选择排序</title>
    <link href="http://yoursite.com/2020/01/30/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/30/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-01-29T16:00:00.000Z</published>
    <updated>2020-03-23T06:37:13.682Z</updated>
    
    <content type="html"><![CDATA[<p>简单选择排序方法：从序列中找到关键字最小的元素，如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换，从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。<br>例子：有一个序列 5，9，6，4，2，8。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>趟：<span class="number">2</span>，<span class="number">9</span>，<span class="number">6</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">8</span> 。</span><br><span class="line">第<span class="number">2</span>趟：<span class="number">2</span>，<span class="number">4</span>，<span class="number">9</span>，<span class="number">6</span>，<span class="number">5</span>，<span class="number">8</span> 。</span><br><span class="line">第<span class="number">3</span>趟：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">9</span>，<span class="number">6</span>，<span class="number">8</span> 。</span><br><span class="line">第<span class="number">4</span>趟：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">8</span> 。</span><br><span class="line">第<span class="number">5</span>趟：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">8</span>，<span class="number">9</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,min;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">min=i;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[min])</span><br><span class="line">min=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min!=i)</span><br><span class="line">swap(a,min,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单选择排序方法：从序列中找到关键字最小的元素，如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换，从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。&lt;br&gt;例子：有一个序列 5，9，6，4，2，8。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2020/01/29/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/29/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-01-28T16:00:00.000Z</published>
    <updated>2020-03-23T06:28:30.851Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序方法：从序列中选一个数做为基准值（一般选第一个），将序列中比他小的值放在他之前，比他大的值放在他之后，再对左右区间重复第二步，直到各区间只有一个数。<br>时间复杂度：O(nlogn)<br>例子：有一个序列 5，9，6，4，2，8。取基准值 temp = 5</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一趟：从序列后面向前查找小于temp的值为<span class="number">2</span>，将<span class="number">2</span>替换第一位，此时<span class="number">2</span>的位置变为空，再从前向后查找大于temp的值为<span class="number">9</span>，将<span class="number">9</span>替换到此前<span class="number">2</span>留下的空，排序后序列为：<span class="number">2</span>，空，<span class="number">6</span>，<span class="number">4</span>，<span class="number">9</span>，<span class="number">8</span></span><br><span class="line">第二趟：继续从序列后面向前查找小于temp的值为<span class="number">4</span>，将其填如前面留下的空位置，此时序列为：<span class="number">2</span>，<span class="number">4</span>，<span class="number">6</span>，空，<span class="number">9</span>，<span class="number">8</span>。再从前向后查找大于temp的值，此时序列为：<span class="number">2</span>，<span class="number">4</span>，空，<span class="number">6</span>，<span class="number">9</span>，<span class="number">8</span>。直到空位置时还没有比temp大的值，因此把temp的值<span class="number">5</span>填入空位置，形成序列：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">8</span>。这时可以发现temp的值前面都是小于他的值，后面都是大于他的值。</span><br><span class="line">第三趟：重复上述操作，得到最终序列：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key=a[low],low_2=low,high_2=high;<span class="comment">//保存当前的上下界</span></span><br><span class="line"><span class="keyword">if</span>(low&gt;high)<span class="comment">//递归终止条件</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high&amp;&amp;a[high]&gt;key)</span><br><span class="line">high--;</span><br><span class="line">a[low]=a[high];</span><br><span class="line"><span class="keyword">while</span>(low&lt;high&amp;&amp;a[low]&lt;key)</span><br><span class="line">low++;</span><br><span class="line">a[high]=a[low];</span><br><span class="line">&#125;</span><br><span class="line">a[low]=key;</span><br><span class="line">QuickSort(a,low_2,low<span class="number">-1</span>);</span><br><span class="line">QuickSort(a,low+<span class="number">1</span>,high_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序方法：从序列中选一个数做为基准值（一般选第一个），将序列中比他小的值放在他之前，比他大的值放在他之后，再对左右区间重复第二步，直到各区间只有一个数。&lt;br&gt;时间复杂度：O(nlogn)&lt;br&gt;例子：有一个序列 5，9，6，4，2，8。取基准值 temp = 5&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://yoursite.com/2020/01/25/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/25/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-03-23T03:12:21.623Z</updated>
    
    <content type="html"><![CDATA[<p>希尔排序方法：先将序列按步长分组，再进行直接插入排序。每次将步长减小一半，直到步长为1时对所有元素进行排序。步长一般是使用序列长度的1/2<br>平均时间复杂度：O(n^1.3)<br>例子：有一个序列 5，9，6，4，2，8<br>长度为 6，取步长为 3 。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一趟：由于步长为 <span class="number">3</span>，因此 <span class="number">5</span> 和 <span class="number">4</span> 比较， <span class="number">9</span> 和 <span class="number">2</span> 比较，<span class="number">6</span> 和 <span class="number">8</span> 比较。小于的话就交换位置。排序后序列为：<span class="number">4</span>，<span class="number">9</span>，<span class="number">6</span>，<span class="number">5</span>，<span class="number">2</span>，<span class="number">8</span></span><br><span class="line">第二趟：取步长为<span class="number">2</span>，因此 <span class="number">4</span>、<span class="number">6</span>、<span class="number">2</span> 比较，<span class="number">9</span>、<span class="number">5</span>、<span class="number">8</span> 比较。排序后序列为：<span class="number">2</span>，<span class="number">5</span>，<span class="number">4</span>，<span class="number">8</span>，<span class="number">6</span>，<span class="number">9</span></span><br><span class="line">第三趟：取步长为<span class="number">1</span>，直接插入排序得到最终序列：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,d=len/<span class="number">2</span>,key;</span><br><span class="line"><span class="keyword">while</span>(d&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=d;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[i-d])</span><br><span class="line">&#123;</span><br><span class="line">key=a[i];</span><br><span class="line"><span class="keyword">for</span>(j=i-d;j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;key;j=j-d)</span><br><span class="line">a[j+d]=a[j];</span><br><span class="line">a[j+d]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">d=d/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希尔排序方法：先将序列按步长分组，再进行直接插入排序。每次将步长减小一半，直到步长为1时对所有元素进行排序。步长一般是使用序列长度的1/2&lt;br&gt;平均时间复杂度：O(n^1.3)&lt;br&gt;例子：有一个序列 5，9，6，4，2，8&lt;br&gt;长度为 6，取步长为 3 。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>直接插入排序</title>
    <link href="http://yoursite.com/2020/01/24/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/24/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-03-23T02:51:22.744Z</updated>
    
    <content type="html"><![CDATA[<p>排序方法：将数组中所有的元素依次和前面排序好的元素进行比较，如果当前选择的元素比已排序过的元素小，则进行交换，直到所有元素都排序完毕。<br><code>直接插入排序的时间复杂度：O(n^2)</code><br>例子：有一个序列 5，9，6，4，2，8</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一趟：<span class="number">9</span>与<span class="number">5</span>比较，大于。序列为：<span class="number">5</span>，<span class="number">9</span>，<span class="number">6</span>，<span class="number">4</span>，<span class="number">2</span>，<span class="number">8</span></span><br><span class="line">第二趟：<span class="number">6</span>与前面的序列比较，大于<span class="number">5</span>，插入<span class="number">5</span>之后。序列为：<span class="number">5</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">4</span>，<span class="number">2</span>，<span class="number">8</span></span><br><span class="line">第三趟：<span class="number">4</span>与前面的序列比较，小于<span class="number">5</span>，插入<span class="number">5</span>之前。序列为：<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">2</span>，<span class="number">8</span></span><br><span class="line">第四趟：<span class="number">2</span>与前面的序列比较，小于<span class="number">4</span>，插入<span class="number">4</span>之前。序列为：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">8</span></span><br><span class="line">第五趟：<span class="number">8</span>与前面的序列比较，大于<span class="number">6</span>小于<span class="number">9</span>，插入<span class="number">6</span>之后<span class="number">9</span>之前。序列为：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,key;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">array</span>[i]&lt;<span class="built_in">array</span>[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">key=<span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">array</span>[j]&gt;key;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">array</span>[j+<span class="number">1</span>]=<span class="built_in">array</span>[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[j+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序方法：将数组中所有的元素依次和前面排序好的元素进行比较，如果当前选择的元素比已排序过的元素小，则进行交换，直到所有元素都排序完毕。&lt;br&gt;&lt;code&gt;直接插入排序的时间复杂度：O(n^2)&lt;/code&gt;&lt;br&gt;例子：有一个序列 5，9，6，4，2，8&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树、森林与二叉树的转换</title>
    <link href="http://yoursite.com/2020/01/22/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/01/22/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-03-23T02:55:49.939Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-树的概念"><a href="#1-树的概念" class="headerlink" title="1. 树的概念"></a>1. 树的概念</h5><p>树是 n（n≥0）个有限数据元素的集合。当n＝0 时，称这棵树为空树。在一棵非空树中：<br>（1）有一个特殊的数据元素称为树的根结点，根结点没有前驱结点。<br>（2）若n&gt;1，除根结点之外的其余数据元素被分成m（m&gt;0）个互不相交的集合T1，T2，…，Tm，其中每一个集合Ti（1≤i≤m）本身又是一棵树。树T1，T2，…，Tm 称为这个根结点的子树。</p><a id="more"></a> <p>树的特点：<br>（1）树的根结点没有前驱结点，除根结点之外的所有结点有且只有一个前驱结点。<br>（2）树中所有结点可以有零个或多个后继结点。</p><h5 id="2-树转换为二叉树"><a href="#2-树转换为二叉树" class="headerlink" title="2. 树转换为二叉树"></a>2. 树转换为二叉树</h5><p>方法：<br>（1）树中所有相邻兄弟之间加一条连线。<br>（2）对树中的每个结点，只保留它与第一个孩子结点之间的连线，删去它与其它孩子结点之间的连线。<br>（3）以树的根结点为轴心，将整棵树顺时针转动一定的角度，使之结构层次分明。</p><h5 id="3-森林转换为二叉树"><a href="#3-森林转换为二叉树" class="headerlink" title="3. 森林转换为二叉树"></a>3. 森林转换为二叉树</h5><p>森林是若干棵树的集合，只要将森林中各棵树的根视为兄弟，每棵树又可以用二叉树表示。<br>方法：<br>（1）将森林中的每棵树转换成相应的二叉树。<br>（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连起来后，此时所得到的二叉树就是由森林转换得到的二叉树。</p><h5 id="4-二叉树转换为树和森林"><a href="#4-二叉树转换为树和森林" class="headerlink" title="4. 二叉树转换为树和森林"></a>4. 二叉树转换为树和森林</h5><p>树和森林都可以转换为二叉树，二者不同的是树转换成的二叉树，其根结点无右分支，而森林转换后的二叉树，其根结点有右分支。可以依据二叉树的根结点有无<code>右分支</code>，将一棵二叉树还原为树或森林，<br>方法如下：<br>（1）若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子都与该结点的双亲结点用线连起来；<br>（2）删去原二叉树中所有的双亲结点与右孩子结点的连线；<br>（3）整理由（1）、（2）两步所得到的树或森林，使之结构层次分明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-树的概念&quot;&gt;&lt;a href=&quot;#1-树的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 树的概念&quot;&gt;&lt;/a&gt;1. 树的概念&lt;/h5&gt;&lt;p&gt;树是 n（n≥0）个有限数据元素的集合。当n＝0 时，称这棵树为空树。在一棵非空树中：&lt;br&gt;（1）有一个特殊的数据元素称为树的根结点，根结点没有前驱结点。&lt;br&gt;（2）若n&amp;gt;1，除根结点之外的其余数据元素被分成m（m&amp;gt;0）个互不相交的集合T1，T2，…，Tm，其中每一个集合Ti（1≤i≤m）本身又是一棵树。树T1，T2，…，Tm 称为这个根结点的子树。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树（最优二叉树）</title>
    <link href="http://yoursite.com/2020/01/20/%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91)/"/>
    <id>http://yoursite.com/2020/01/20/%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91)/</id>
    <published>2020-01-19T16:00:00.000Z</published>
    <updated>2020-03-22T12:49:37.845Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1．哈夫曼树的概念"><a href="#1．哈夫曼树的概念" class="headerlink" title="1．哈夫曼树的概念"></a>1．哈夫曼树的概念</h5><p>最优二叉树，也称哈夫曼（Haffman）树，是指对于一组带有确定权值的叶结点，构造的具有最小带权路径长度的二叉树。</p><h5 id="2-二叉树的带权路径长度"><a href="#2-二叉树的带权路径长度" class="headerlink" title="2 . 二叉树的带权路径长度"></a>2 . 二叉树的带权路径长度</h5><p>相同权值的一组叶子结点所构成的二叉树有不同的形态和不同的带权路径长度。根据哈夫曼树的定义，一棵二叉树要使其WPL 值最小，必须使权值越大的叶结点越靠近根结点，而权值越小的叶结点越远离根结点。</p><a id="more"></a><p>方法：<br>（1）由给定的 n 个权值{W1，W2，…，Wn}构造n 棵只有一个叶结点的二叉树，从而得到一个二叉树的集合F＝{T1，T2，…，Tn}；<br>（2）在F 中选取根结点的权值最小和次小的两棵二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根结点的权值为其左、右子树根结点权值之和；<br>（3）在集合F 中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F 中；<br>（4）重复（2）（3）两步，当F 中只剩下一棵二叉树时，这棵二叉树便是所要建立的哈夫曼树。</p><h5 id="3-哈夫曼树的构造算法"><a href="#3-哈夫曼树的构造算法" class="headerlink" title="3 . 哈夫曼树的构造算法"></a>3 . 哈夫曼树的构造算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVALUE 10000 <span class="comment">/*定义最大权值*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEAF 30 <span class="comment">/*定义哈夫曼树中叶子结点个数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNODE MAXLEAF*2-1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">int</span> parent;</span><br><span class="line"><span class="keyword">int</span> lchild;</span><br><span class="line"><span class="keyword">int</span> rchild;</span><br><span class="line">&#125;HNodeType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HaffmanTree</span><span class="params">(HNodeType HuffNode [ ])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*哈夫曼树的构造算法*/</span></span><br><span class="line"><span class="keyword">int</span> i,j,m1,m2,x1,x2,n;</span><br><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;n); <span class="comment">/*输入叶子结点个数*/</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++) <span class="comment">/*数组HuffNode[ ]初始化*/</span></span><br><span class="line">&#123; HuffNode[i].weight=<span class="number">0</span>;</span><br><span class="line">HuffNode[i].parent=<span class="number">-1</span>;</span><br><span class="line">HuffNode[i].lchild=<span class="number">-1</span>;</span><br><span class="line">HuffNode[i].rchild=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;HuffNode[i].weight); <span class="comment">/*输入n 个叶子结点的权值*/</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) <span class="comment">/*构造哈夫曼树*/</span></span><br><span class="line">&#123; </span><br><span class="line">m1=m2=MAXVALUE;</span><br><span class="line">x1=x2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n+i;j++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (HuffNode[j].weight&lt;m1 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">&#123; </span><br><span class="line">m2=m1; x2=x1;</span><br><span class="line">m1=HuffNode[j].weight; x1=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight&lt;m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">&#123; </span><br><span class="line">m2=HuffNode[j].weight;</span><br><span class="line">x2=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将找出的两棵子树合并为一棵子树*/</span></span><br><span class="line">HuffNode[x1].parent=n+i; HuffNode[x2].parent=n+i;</span><br><span class="line">HuffNode[n+i].weight= HuffNode[x1].weight+HuffNode[x2].weight;</span><br><span class="line">HuffNode[n+i].lchild=x1; HuffNode[n+i].rchild=x2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-哈夫曼编码算法"><a href="#4-哈夫曼编码算法" class="headerlink" title="4. 哈夫曼编码算法"></a>4. 哈夫曼编码算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBIT 10 <span class="comment">/*定义哈夫曼编码的最大长度*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> bit[MAXBIT];</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line">&#125;HCodeType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HaffmanCode</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/*生成哈夫曼编码*/</span></span><br><span class="line">HNodeType HuffNode[MAXNODE];</span><br><span class="line">HCodeType HuffCode[MAXLEAF],cd;</span><br><span class="line"><span class="keyword">int</span> i,j, c,p;</span><br><span class="line">HuffmanTree (HuffNode ); <span class="comment">/*建立哈夫曼树*/</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">/*求每个叶子结点的哈夫曼编码*/</span></span><br><span class="line">&#123; </span><br><span class="line">cd.start=n<span class="number">-1</span>; c=i;</span><br><span class="line">p=HuffNode[c].parent;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="number">0</span>) <span class="comment">/*由叶结点向上直到树根*/</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (HuffNode[p].lchild==c) cd.bit[cd.start]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> cd.bit[cd.start]=<span class="number">1</span>;</span><br><span class="line">cd.start--; c=p;</span><br><span class="line">p=HuffNode[c].parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j=cd.start+<span class="number">1</span>;j&lt;n;j++) <span class="comment">/*保存求出的每个叶结点的哈夫曼编码和编码的起始位*/</span></span><br><span class="line">HuffCode[i].bit[j]=cd.bit[j];</span><br><span class="line">HuffCode[i].start=cd.start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">/*输出每个叶子结点的哈夫曼编码*/</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">for</span> (j=HuffCode[i].start+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line"><span class="built_in">printf</span>(“%ld”,HuffCode[i].bit[j]);</span><br><span class="line"><span class="built_in">printf</span>(“\n”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1．哈夫曼树的概念&quot;&gt;&lt;a href=&quot;#1．哈夫曼树的概念&quot; class=&quot;headerlink&quot; title=&quot;1．哈夫曼树的概念&quot;&gt;&lt;/a&gt;1．哈夫曼树的概念&lt;/h5&gt;&lt;p&gt;最优二叉树，也称哈夫曼（Haffman）树，是指对于一组带有确定权值的叶结点，构造的具有最小带权路径长度的二叉树。&lt;/p&gt;
&lt;h5 id=&quot;2-二叉树的带权路径长度&quot;&gt;&lt;a href=&quot;#2-二叉树的带权路径长度&quot; class=&quot;headerlink&quot; title=&quot;2 . 二叉树的带权路径长度&quot;&gt;&lt;/a&gt;2 . 二叉树的带权路径长度&lt;/h5&gt;&lt;p&gt;相同权值的一组叶子结点所构成的二叉树有不同的形态和不同的带权路径长度。根据哈夫曼树的定义，一棵二叉树要使其WPL 值最小，必须使权值越大的叶结点越靠近根结点，而权值越小的叶结点越远离根结点。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="http://yoursite.com/2020/01/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2020/01/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2020-01-17T16:00:00.000Z</published>
    <updated>2020-03-23T02:57:13.002Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的遍历是指按照某种顺序访问二叉树中的每个结点，使每个结点被访问一次且仅被访问一次。<br>一棵树由根结点、根结点的左子树和根结点的右子树三部分组成。只要依次遍历这三部分，就可以遍历整个二叉树。<br>若以D、L、R 分别表示访问根结点、遍历根结点的左子树、遍历根结点的右子树，则二叉树的遍历三种方式：DLR（先序遍历）、LDR（中序遍历）和LRD（后序遍历）。<a id="more"></a> </p><h5 id="1．先序遍历（DLR）"><a href="#1．先序遍历（DLR）" class="headerlink" title="1．先序遍历（DLR）"></a>1．先序遍历（DLR）</h5><p>先序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1）访问根结点；<br>（2）先序遍历根结点的左子树；<br>（3）先序遍历根结点的右子树。<br>递归算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PreOrder（BiTree bt）</span><br><span class="line"><span class="comment">/*先序遍历二叉树bt*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span>; <span class="comment">/*递归调用的结束条件*/</span></span><br><span class="line">Visite（bt-&gt;data）; <span class="comment">/*访问结点的数据域*/</span></span><br><span class="line">PreOrder（bt-&gt;lchild）; <span class="comment">/*先序递归遍历bt 的左子树*/</span></span><br><span class="line">PreOrder（bt-&gt;rchild）; <span class="comment">/*先序递归遍历bt 的右子树*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2．中序遍历（LDR）"><a href="#2．中序遍历（LDR）" class="headerlink" title="2．中序遍历（LDR）"></a>2．中序遍历（LDR）</h5><p>中序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1）中序遍历根结点的左子树；<br>（2）访问根结点；<br>（3）中序遍历根结点的右子树。</p><p>递归算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InOrder（BiTree bt）</span><br><span class="line"><span class="comment">/*中序遍历二叉树bt*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span>; <span class="comment">/*递归调用的结束条件*/</span></span><br><span class="line">InOrder（bt-&gt;lchild）; <span class="comment">/*中序递归遍历bt 的左子树*/</span></span><br><span class="line">Visite（bt-&gt;data）; <span class="comment">/*访问结点的数据域*/</span></span><br><span class="line">InOrder（bt-&gt;rchild）; <span class="comment">/*中序递归遍历bt 的右子树*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3．后序遍历（LRD）"><a href="#3．后序遍历（LRD）" class="headerlink" title="3．后序遍历（LRD）"></a>3．后序遍历（LRD）</h5><p>后序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1）后序遍历根结点的左子树；<br>（2）后序遍历根结点的右子树。<br>（3）访问根结点；<br>递归算法：<br>void PostOrder（BiTree bt）<br>/<em>后序遍历二叉树bt</em>/</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span>; <span class="comment">/*递归调用的结束条件*/</span></span><br><span class="line">PostOrder（bt-&gt;lchild）; <span class="comment">/*后序递归遍历bt 的左子树*/</span></span><br><span class="line">PostOrder（bt-&gt;rchild）; <span class="comment">/*后序递归遍历bt 的右子树*/</span></span><br><span class="line">Visite（bt-&gt;data）; <span class="comment">/*访问结点的数据域*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的遍历是指按照某种顺序访问二叉树中的每个结点，使每个结点被访问一次且仅被访问一次。&lt;br&gt;一棵树由根结点、根结点的左子树和根结点的右子树三部分组成。只要依次遍历这三部分，就可以遍历整个二叉树。&lt;br&gt;若以D、L、R 分别表示访问根结点、遍历根结点的左子树、遍历根结点的右子树，则二叉树的遍历三种方式：DLR（先序遍历）、LDR（中序遍历）和LRD（后序遍历）。
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-01-12T16:00:00.000Z</published>
    <updated>2020-03-22T13:03:09.736Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-二叉树的概念"><a href="#1-二叉树的概念" class="headerlink" title="1. 二叉树的概念"></a>1. 二叉树的概念</h5><p>二叉树是个有限元素的集合，由一个根元素及两个不相交的、左子树和右子树组成二叉树。该集合为空时称做空二叉树。在二叉树中，一个元素也称作一个结点。</p><a id="more"></a><h5 id="2-二叉树的相关概念"><a href="#2-二叉树的相关概念" class="headerlink" title="2. 二叉树的相关概念"></a>2. 二叉树的相关概念</h5><ol><li>结点的度：结点所拥有的子树的个数称为该结点的度。</li><li>叶结点：度为0 的结点称为叶结点。</li><li>分枝结点：度不为0 的结点称为分支结点。一棵树的结点除叶结点外，其余的都是分支结点。</li><li>路径、路径长度。如果一棵树的一串结点n1,n2,…,nk 有如下关系：结点ni 是ni+1的父结点（1≤i&lt;k），就把n1,n2,…,nk 称为一条由n1 至nk 的路径。这条路径的长度是<code>k-1</code>。</li><li>树的深度：树中所有结点的最大层数称为树的深度。</li><li>树的度：树中各结点度的最大值称为该树的度。</li><li>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上。</li><li>完全二叉树：一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。<code>完全二叉树的特点是：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。</code><h5 id="3-二叉树的主要性质"><a href="#3-二叉树的主要性质" class="headerlink" title="3.  二叉树的主要性质"></a>3.  二叉树的主要性质</h5>性质1：一棵非空二叉树的第i 层上最多有<code>2i-1</code> 个结点（i≥1）。</li></ol><p>性质2 ：一棵深度为k 的二叉树中，最多具有<code>2k－1</code> 个结点。</p><p>性质3 ：对于一棵非空的二叉树，如果叶子结点数为n0，度数为2 的结点数为n2，则有：<code>n0＝n2＋1</code>。</p><p>性质4 具有n 个结点的完全二叉树的深度 k 为 <code>[log2n]+1</code>。</p><p>性质5 ：对于具有n 个结点的完全二叉树，如果按照从上至下和从左到右的顺序对二叉树中的所有结点从1 开始顺序编号，则对于任意的序号为i 的结点，有：</p><ul><li>如果i&gt;1，则序号为i 的结点的双亲结点的序号为i/2(“/”表示整除)；如果i＝1，则序号为i 的结点是根结点，无双亲结点。</li><li>如果2i≤n，则序号为i 的结点的左孩子结点的序号为2i；如果2i&gt;n，则序号为i 的结点无左孩子。</li><li>如果2i＋1≤n，则序号为i 的结点的右孩子结点的序号为2i＋1；如果2i＋1&gt;n，则序号为i 的结点无右孩子。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-二叉树的概念&quot;&gt;&lt;a href=&quot;#1-二叉树的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 二叉树的概念&quot;&gt;&lt;/a&gt;1. 二叉树的概念&lt;/h5&gt;&lt;p&gt;二叉树是个有限元素的集合，由一个根元素及两个不相交的、左子树和右子树组成二叉树。该集合为空时称做空二叉树。在二叉树中，一个元素也称作一个结点。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
