<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风之落木</title>
  
  <subtitle>寄君一曲，不问曲终人聚散。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-23T02:56:20.746Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王邦雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文件与目录管理</title>
    <link href="http://yoursite.com/2020/03/19/Linux%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/19/Linux%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-03-23T02:56:20.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常见的处理目录命令"><a href="#一、常见的处理目录命令" class="headerlink" title="一、常见的处理目录命令"></a>一、常见的处理目录命令</h1><p>ls: 列出目录<br>cd：切换目录<br>pwd：显示目前的目录<br> <a id="more"></a> mkdir：创建一个新的目录<br>rmdir：删除一个空的目录<br>cp: 复制文件或目录<br>rm: 移除文件或目录<br>mv: 移动文件与目录，或修改文件与目录的名称  </p><h2 id="1、ls-命令"><a href="#1、ls-命令" class="headerlink" title="1、ls 命令"></a>1、ls 命令</h2><p>语法：<code>ls 目录名称</code><br>[root@www ~]# ls -a 目录名称<br>[root@www ~]# ls -d 目录名称<br>[root@www ~]# ls -l 目录名称<br>选项与参数：<br>-a ：列出全部的文件，包括隐藏文件。<br>-d ：只列出目录本身。<br>-l ：长数据串列出，包含文件的属性与权限等等数据。</p><h2 id="2、cd-命令"><a href="#2、cd-命令" class="headerlink" title="2、cd 命令"></a>2、cd 命令</h2><p>用来切换工作目录的命令。<br>语法：<code>cd [相对路径或绝对路径]</code></p><ul><li>使用绝对路径切换到 test 目录<code>cd /root/test/</code></li><li>使用相对路径切换到 test 目录<code>cd ./runoob/</code></li><li>切换到家目录，即 /root 目录<code>cd ~</code></li><li>切换到当前的上一级目录，即 /root 的上一级目录<code>cd ..</code><h2 id="3、pwd-命令"><a href="#3、pwd-命令" class="headerlink" title="3、pwd 命令"></a>3、pwd 命令</h2>pwd 是显示当前所在目录的命令。<br>语法： <code>pwd [-P]</code><br>选项与参数：</li><li>P ：显示出完整的路径。<h2 id="4、mkdir-命令"><a href="#4、mkdir-命令" class="headerlink" title="4、mkdir 命令"></a>4、mkdir 命令</h2>使用 mkdir 命令创建一个新的目录<br>语法：<code>mkdir 目录名称[test]</code><br>选项与参数：</li><li>m ：配置文件的权限，直接配置。</li><li>p ：可以自行帮你创建多层目录。<h2 id="5、rmdir-命令"><a href="#5、rmdir-命令" class="headerlink" title="5、rmdir 命令"></a>5、rmdir 命令</h2>使用rmdir 命令删除空的目录<br>语法：<code>rmdir [-p] 目录名称</code><br>选项与参数：</li><li>p ：连同上一级『空的』目录也一起删除<br><code>注意：rmdir 只能删除空的目录，可以使用 rm 命令来删除非空目录。</code></li></ul><h2 id="6、cp-命令"><a href="#6、cp-命令" class="headerlink" title="6、cp 命令"></a>6、cp 命令</h2><p>使用cp命令复制文件或目录。<br>语法:<code>cp - [a d f i l p r s u] 来源档(source) 目标档(destination)</code><br>选项与参数：<br>-a：相当于 -pdr 。</p><p>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身。</p><p>-f：若目标文件已经存在且无法开启，则移除后再尝试一次。</p><p>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行。</p><p>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。</p><p>-p：连同文件的属性一起复制过去。</p><p>-r：递归持续复制，用于目录的复制。</p><p>-s：复制成为符号连结档 (symbolic link)。</p><p>-u：若 destination 比 source 旧才升级 destination。</p><h2 id="7、rm-命令"><a href="#7、rm-命令" class="headerlink" title="7、rm 命令"></a>7、rm 命令</h2><p>使用rm命令移除文件或目录<br>语法：<code>rm [-fir] 文件或目录</code><br>选项与参数：<br>-f ：忽略不存在的文件，不会出现警告信息。</p><p>-i ：互动模式，在删除前会询问使用者是否动作。<br>-r ：递归删除</p><h2 id="8、mv"><a href="#8、mv" class="headerlink" title="8、mv"></a>8、mv</h2><p>使用 mv 命令移动文件与目录。<br>语法：<code>mv [-fiu] source destination</code><br>选项与参数：</p><p>-f ：若目标文件已存在，不会询问而直接覆盖。</p><p>-i ：若目标文件已存在，就会询问是否覆盖。</p><p>-u ：若目标文件已存在，且 source 比较新，才会升级 (update)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、常见的处理目录命令&quot;&gt;&lt;a href=&quot;#一、常见的处理目录命令&quot; class=&quot;headerlink&quot; title=&quot;一、常见的处理目录命令&quot;&gt;&lt;/a&gt;一、常见的处理目录命令&lt;/h1&gt;&lt;p&gt;ls: 列出目录&lt;br&gt;cd：切换目录&lt;br&gt;pwd：显示目前的目录&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议</title>
    <link href="http://yoursite.com/2020/03/19/TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/03/19/TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-03-22T07:18:41.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP传输控制协议"><a href="#TCP传输控制协议" class="headerlink" title="TCP传输控制协议"></a>TCP传输控制协议</h1><p>TCP传输控制协议是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。 <a id="more"></a> </p><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h5 id="1、建立TCP连接（三次握手）"><a href="#1、建立TCP连接（三次握手）" class="headerlink" title="1、建立TCP连接（三次握手）"></a>1、建立TCP连接（三次握手）</h5><p>第一次握手：客户端发送TCP报文到服务器，等待服务器确认。<br>第二次握手：服务器端接收客户端发来的报文并确认，同时自己也发送一个SYN包给客户端，询问客户端是否准备好进行数据通讯。<br>第三次握手： 客户端收到服务器的SYN+ACK包，并回应服务端一个ACK报文。</p><h5 id="2、终止TCP连接（四次挥手）"><a href="#2、终止TCP连接（四次挥手）" class="headerlink" title="2、终止TCP连接（四次挥手）"></a>2、终止TCP连接（四次挥手）</h5><p>第一次挥手：客户端发出连接释放报文，并且停止客户端到服务器的数据传送。<br>第二次挥手：服务器收到连接释放报文，发出确认报文。<br>第三次挥手：服务器发送一个FIN给客户端，用来关闭与客户端的数据传送。<br>第四次挥手：客户段收到FIN后发回一个ACK报文给服务器，完成四次挥手。</p><h5 id="为什么连接时是三次握手，释放时却是四次握手？"><a href="#为什么连接时是三次握手，释放时却是四次握手？" class="headerlink" title="为什么连接时是三次握手，释放时却是四次握手？"></a>为什么连接时是三次握手，释放时却是四次握手？</h5><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><p>TCP还设有一个保活计时器。服务器每收到一次客户端的请求后都会重新复位这个计时器，若没有收到客户端的任何数据，服务器就会发送一个探测报文段。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP：提供的是面向连接的、传输效率低，可靠性强<br>UDP：提供的是非面向连接的、适用于传输可靠性要求不高，数据量小的数据</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP传输控制协议&quot;&gt;&lt;a href=&quot;#TCP传输控制协议&quot; class=&quot;headerlink&quot; title=&quot;TCP传输控制协议&quot;&gt;&lt;/a&gt;TCP传输控制协议&lt;/h1&gt;&lt;p&gt;TCP传输控制协议是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux vim显示行号的设置方法</title>
    <link href="http://yoursite.com/2020/03/18/Linux%20vim%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/18/Linux%20vim%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2020-03-22T02:05:41.556Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，vim打开文件时不提示行号。<br>临时显示行号：<code>在vim模式下输入 set nu 命令。</code><br>关闭当前打开的vim后就失效。<a id="more"></a><br>如果想每次打开vim都显示行号，则需要修改其配置文件，用户的配置文件放在用户主目录下以 <code>.vimrc</code> 命名。<br>修改配置文件：<br>输入命令：vim   ~/.vimrc，打开文件后，添加 set nu，保存退出，再次用vim打开文件时就可以显示行号了。</p><p>取消显示行号：<code>在vim命令行模式下输入set nonu</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认情况下，vim打开文件时不提示行号。&lt;br&gt;临时显示行号：&lt;code&gt;在vim模式下输入 set nu 命令。&lt;/code&gt;&lt;br&gt;关闭当前打开的vim后就失效。
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>功能测试</title>
    <link href="http://yoursite.com/2020/03/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/03/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2020-03-22T07:18:55.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="功能测试的概念"><a href="#功能测试的概念" class="headerlink" title="功能测试的概念"></a>功能测试的概念</h3><p>功能测试就是对产品的各功能进行验证，根据功能测试用例逐项测试，检查产品是否达到用户要求的功能；只需要考虑它的功能点不需要考虑软件的内部结构及代码等。<a id="more"></a> </p><h6 id="1-1图形测试"><a href="#1-1图形测试" class="headerlink" title="1.1图形测试"></a>1.1图形测试</h6><p>包括图片、动画、边框、颜色、字体、背景、按钮等。<br>其中要考虑以下几个重点：<br>（1）图片要有明确的用途；图片尺寸尽量小，格式一般采用JPG/GIF。<br>（2）页面整体风格是否和系统的用途一致。<br>（3）背景颜色、字体搭配是否合理。</p><h6 id="1-2表单测试"><a href="#1-2表单测试" class="headerlink" title="1.2表单测试"></a>1.2表单测试</h6><p>当用户在web应用系统上向服务器提交信息时，就需要使用表单操作，例如用户注册，登录，信息变更等。在该情况下，我们必须测试提交信息的完整性，以检验提交给服务器的数据的正确性。</p><h6 id="1-3内容测试"><a href="#1-3内容测试" class="headerlink" title="1.3内容测试"></a>1.3内容测试</h6><p>主要用来检测web系统提供信息的准确性、相关性。如：信息的准确性，拼写是否有误；价格，文字描述是否有误；信息的相关性，如相关文章列表，视频列表等。</p><h6 id="1-4链接测试"><a href="#1-4链接测试" class="headerlink" title="1.4链接测试"></a>1.4链接测试</h6><p> 链接主要用于页面之间切换跳转，指导用户去一些不知道地址的页面的主要手段，链接测试一般关注三点：<br>（1）链接是否按照既定指示那样，确实链接到了该链接的界面。<br>（2）测试该链接所链接的页面是否真的存在。<br>（3）保证系统中没有单独存在的页面。</p><h6 id="1-5导航测试"><a href="#1-5导航测试" class="headerlink" title="1.5导航测试"></a>1.5导航测试</h6><p>导航测试就是在不同的页面跳转之间，通过按钮，对话框，列表以及窗口等因素，去判断一个应用系统是否易于导航；是否直观；站点是否需要站内地图或者搜索引擎等其他帮助；web系统导航的另外一个重点就是页面结构、导航、菜单、风格等是否一致。确保用户可以凭借简单的判断就可以找到自己想要的内容。</p><h6 id="1-6整体界面测试"><a href="#1-6整体界面测试" class="headerlink" title="1.6整体界面测试"></a>1.6整体界面测试</h6><p>整体界面测试就是测试用户浏览时是否感觉舒适。一般做一个类似问卷调查的形式，来判定用户的反馈信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;功能测试的概念&quot;&gt;&lt;a href=&quot;#功能测试的概念&quot; class=&quot;headerlink&quot; title=&quot;功能测试的概念&quot;&gt;&lt;/a&gt;功能测试的概念&lt;/h3&gt;&lt;p&gt;功能测试就是对产品的各功能进行验证，根据功能测试用例逐项测试，检查产品是否达到用户要求的功能；只需要考虑它的功能点不需要考虑软件的内部结构及代码等。
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL 数据库基础知识</title>
    <link href="http://yoursite.com/2020/03/17/SQL%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/03/17/SQL%20%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-16T16:00:00.000Z</published>
    <updated>2020-03-22T02:04:55.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、SQL-SELECT-语句"><a href="#1、SQL-SELECT-语句" class="headerlink" title="1、SQL SELECT 语句"></a>1、SQL SELECT 语句</h1><p>SELECT 语句用于从数据库中选取数据，结果被存储在一个结果表中。<br>语法：<code>SELECT 列名称 FROM 表名;</code>与<code>与SELECT * FROM 表名;</code>  <a id="more"></a> </p><h1 id="2、SQL-SELECT-DISTINCT-语句"><a href="#2、SQL-SELECT-DISTINCT-语句" class="headerlink" title="2、SQL SELECT DISTINCT 语句"></a>2、SQL SELECT DISTINCT 语句</h1><p>SELECT DISTINCT 语句用于返回唯一不同的值。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名称 FROM 表名;</span><br></pre></td></tr></table></figure><h1 id="3、SQL-WHERE-子句"><a href="#3、SQL-WHERE-子句" class="headerlink" title="3、SQL WHERE 子句"></a>3、SQL WHERE 子句</h1><p>WHERE 子句用于提取那些满足指定条件的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">SELECT 列名 FROM 表名</span><br><span class="line">WHERE 列名 operator value;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例：从 &quot;test&quot; 表中选取地名为 &quot;SH&quot; 的所有网站</span><br><span class="line">SELECT * FROM test WHERE place&#x3D;&#39;SH&#39;;</span><br></pre></td></tr></table></figure><p>SQL 使用单引号来环绕文本值，如果是数值字段，不使用引号。<br>如：<code>SELECT * FROM test WHERE value=1;</code><br>WHERE 子句中的运算符<br>运算符     | 描述<br>——– | —–<br>=  | 等于<br>&lt;&gt;或！=  | 不等于</p><blockquote><p> | 大于<br>&lt;  | 小于<br>=  | 大于等于<br>&lt;=  | 小于等于<br>LIKE  | 搜索某种模式<br>BETWEEN | 在某个范围内<br>IN    | 指定针对某个列的多个可能值</p></blockquote><h1 id="4、SQL-AND-amp-OR-运算符"><a href="#4、SQL-AND-amp-OR-运算符" class="headerlink" title="4、SQL AND &amp; OR 运算符"></a>4、SQL AND &amp; OR 运算符</h1><p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p><ul><li>若第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</li><li>若第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</li></ul><p>把 AND 和 OR 结合起来，使用圆括号来组成复杂的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">SELECT * FROM test</span><br><span class="line">WHERE id &gt; 8</span><br><span class="line">AND (place&#x3D;&#39;HC&#39; OR place&#x3D;&#39;CN&#39;);</span><br></pre></td></tr></table></figure><h1 id="5、SQL-ORDER-BY-关键字"><a href="#5、SQL-ORDER-BY-关键字" class="headerlink" title="5、SQL ORDER BY 关键字"></a>5、SQL ORDER BY 关键字</h1><p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。<br>ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，可以使用 DESC 关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">ORDER BY 列名 ASC|DESC;</span><br></pre></td></tr></table></figure><p>ORDER BY 多列时：<br>order by A,B        这个时候都是默认按升序排列<br>order by A desc,B   这个时候 A 降序，B 升序排列<br>order by A ,B desc  这个时候 A 升序，B 降序排列<br><code>即 desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序。</code></p><h1 id="6、SQL-INSERT-INTO-语句"><a href="#6、SQL-INSERT-INTO-语句" class="headerlink" title="6、SQL INSERT INTO 语句"></a>6、SQL INSERT INTO 语句</h1><p>INSERT INTO 语句用于向表中插入新记录。<br>INSERT INTO 语句可以有两种编写形式。</p><ul><li>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名</span><br><span class="line">VALUES (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><ul><li>第二种形式需要指定列名及被插入的值：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (列名1,列名2,...)</span><br><span class="line">VALUES (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p><code>insert into select 和 select into from 的区别</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into scorebak select * from socre where neza&#x3D;&#39;neza&#39;   插入一行，要求表scorebak 必须存在</span><br><span class="line">select *  into scorebak from score  where neza&#x3D;&#39;neza&#39;  插入一行，要求表scorebak 不存在</span><br></pre></td></tr></table></figure><h1 id="7、SQL-UPDATE-语句"><a href="#7、SQL-UPDATE-语句" class="headerlink" title="7、SQL UPDATE 语句"></a>7、SQL UPDATE 语句</h1><p>UPDATE 语句用于更新表中已存在的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">UPDATE 表名</span><br><span class="line">SET 列名1&#x3D;value1,列名2&#x3D;value2,...</span><br><span class="line">WHERE 列名&#x3D;value;</span><br></pre></td></tr></table></figure><p><code>慎重执行没有 WHERE 子句的 UPDATE</code><br>在 MySQL 中可以通过设置 sql_safe_updates 这个自带的参数来解决，当该参数开启的情况下，你必须在update 语句后携带 where 条件，否则就会报错。<br>set sql_safe_updates=1; 表示开启该参数</p><h1 id="8、SQL-DELETE-语句"><a href="#8、SQL-DELETE-语句" class="headerlink" title="8、SQL DELETE 语句"></a>8、SQL DELETE 语句</h1><p>DELETE 语句用于删除表中的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">DELETE FROM 表名</span><br><span class="line">WHERE 列名&#x3D;value;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line">DELETE FROM test</span><br><span class="line">WHERE name&#x3D;&#39;百度&#39; AND place&#x3D;&#39;SH&#39;;</span><br></pre></td></tr></table></figure><ul><li>删除所有数据<br>可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名; 或 DELETE * FROM 表名;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL关于删除的三个语句：DROP、TRUNCATE、 DELETE 的区别。</span><br><span class="line">相同点：drop、delete、truncate 都是删除表的内容。</span><br><span class="line">不同点：</span><br><span class="line"> delete：删除表的内容，表的结构还存在，不释放空间，可以回滚恢复；</span><br><span class="line"> drop：删除表内容和结构，释放空间，没有备份表之前要慎用；</span><br><span class="line"> truncate：删除表的内容，表的结构存在，可以释放空间,没有备份表之前要慎用；</span><br><span class="line">执行速度：</span><br><span class="line">drop &gt; truncate &gt; delete</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、SQL-SELECT-语句&quot;&gt;&lt;a href=&quot;#1、SQL-SELECT-语句&quot; class=&quot;headerlink&quot; title=&quot;1、SQL SELECT 语句&quot;&gt;&lt;/a&gt;1、SQL SELECT 语句&lt;/h1&gt;&lt;p&gt;SELECT 语句用于从数据库中选取数据，结果被存储在一个结果表中。&lt;br&gt;语法：&lt;code&gt;SELECT 列名称 FROM 表名;&lt;/code&gt;与&lt;code&gt;与SELECT * FROM 表名;&lt;/code&gt;
    
    </summary>
    
    
    
      <category term="SQL数据库" scheme="http://yoursite.com/tags/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>软件测试理论基础</title>
    <link href="http://yoursite.com/2020/03/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/03/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-15T16:00:00.000Z</published>
    <updated>2020-03-22T02:03:26.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、软件测试概念"><a href="#一、软件测试概念" class="headerlink" title="一、软件测试概念"></a>一、软件测试概念</h1><p> 通过手工或工具对“被测对象”进行测试操作，从而验证实际与预期结果之间是否存在差异。<a id="more"></a> </p><h1 id="二、软件测试原则"><a href="#二、软件测试原则" class="headerlink" title="二、软件测试原则"></a>二、软件测试原则</h1><p>1、测试证明软件存在缺陷。<br>2、不能执行穷尽测试。<br>3、缺陷存在群集现象，对于软件功能来说，核心功能占20%，非核心是80%，集中测试20%的核心功能发现缺陷的几率高。<br>4、某些测试需要依赖特殊的环境。<br>5、尽可能早的开展测试。<br>6、杀虫剂现象：同样的一个测试用例不能重复的执行多次。<br>7、不存在缺陷谬论。</p><h1 id="三、测试级别"><a href="#三、测试级别" class="headerlink" title="三、测试级别"></a>三、测试级别</h1><p>软件开发都会依据相应的开发模型，测试级别指的就是在这个模型当中我们认为定义的开发步骤。<br>1、单元测试：指的是组成软件最小的底层代码结构，一般都是类、函数、组件等。<br>2、集成测试（接口测试）：将多个单元模块组合在一起，验证它们之间沟通的桥梁是否能正常工作。<br>3、系统测试：由测试人员充当用户然后对软件的功能主体进行测试。</p><h1 id="四、系统测试分类"><a href="#四、系统测试分类" class="headerlink" title="四、系统测试分类"></a>四、系统测试分类</h1><p>1、功能测试：验证当前软件主体功能是否可用。<br>2、兼容性测试：验证当前软件在不同的环境下是否还可以使用。<br>3、安全性测试：验证软件是否只是能授权用户提供功能使用。<br>4、性能测试：相对于当前软件消耗的资源，它的产出能力。</p><h1 id="五、软件测试流程"><a href="#五、软件测试流程" class="headerlink" title="五、软件测试流程"></a>五、软件测试流程</h1><p>1、需求分析</p><ul><li>核心目的：弄清楚要测啥。</li><li>需求来源：需求规格说明书、API文档、同行竞品分析等。</li></ul><p>2、设计用例  </p><ul><li>用例就是用户为了测试软件的某个功能而执行的操作过程。</li><li>设计用例的方法有：等价类、边界值、因果图等。</li></ul><p>3、评审用例</p><ul><li>对当前的用例进行添加或删除。</li></ul><p>4、配置环境</p><ul><li>环境分类：操作系统、服务器软件、数据库、软件底层代码的执行环境。</li></ul><p>5、执行用例</p><ul><li>执行前先做冒烟测试，其核心是快速的对当前软件的核心功能进行验证。</li></ul><p>6、回归测试及缺陷跟踪</p><ul><li>目的是检验已经被发现的缺陷有没有被正确的修改和修改过程中有没有引发新的缺陷。软件在测试或者其他活动中发现的缺陷经过修改后，都要进行回归测试的验证。</li></ul><p>7、输出测试报告</p><ul><li>将当前的测试过程中产生的数据进行可视化的输出。</li></ul><p>8、测试结束</p><ul><li>把测试过程的文档进行整理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、软件测试概念&quot;&gt;&lt;a href=&quot;#一、软件测试概念&quot; class=&quot;headerlink&quot; title=&quot;一、软件测试概念&quot;&gt;&lt;/a&gt;一、软件测试概念&lt;/h1&gt;&lt;p&gt; 通过手工或工具对“被测对象”进行测试操作，从而验证实际与预期结果之间是否存在差异。
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>VBScript函数</title>
    <link href="http://yoursite.com/2020/02/15/VBScript%20%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/15/VBScript%20%E5%87%BD%E6%95%B0/</id>
    <published>2020-02-14T16:00:00.000Z</published>
    <updated>2020-03-22T07:54:18.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="String-函数"><a href="#String-函数" class="headerlink" title="String 函数"></a>String 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">InStr返回字符串在另一字符串中首次出现的位置。检索从字符串的第一个字符开始 &lt;!-- more --&gt;</span><br><span class="line"> </span><br><span class="line">InStrRev返回字符串在另一字符串中首次出现的位置。检索从字符串的最末字符开始</span><br><span class="line">LCase把指定字符串转换为小写</span><br><span class="line">Left从字符串的左侧返回指定数目的字符</span><br><span class="line">Len返回字符串中的字符数目</span><br><span class="line">LTrim删除字符串左侧的空格</span><br><span class="line">RTrim删除字符串右侧的空格</span><br><span class="line">Trim删除字符串左侧和右侧的空格</span><br><span class="line">Mid从字符串返回指定数目的字符</span><br><span class="line">Replace使用另外一个字符串替换字符串的指定部分指定的次数</span><br><span class="line">Right返回从字符串右侧开始指定数目的字符</span><br><span class="line">Space返回由指定数目的空格组成的字符串</span><br><span class="line">StrComp比较两个字符串，返回代表比较结果的一个值</span><br><span class="line">String返回包含指定长度的重复字符的字符串</span><br><span class="line">StrReverse反转字符串</span><br><span class="line">UCase把指定的字符串转换为大写</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Date-和-Time-函数"><a href="#Date-和-Time-函数" class="headerlink" title="Date 和 Time 函数"></a>Date 和 Time 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CDate       把一个有效的日期或时间表达式转换为日期类型</span><br><span class="line">Date       返回当前的系统日期</span><br><span class="line">DateAdd       返回已添加指定时间间隔的日期</span><br><span class="line">DateDiff       返回两个日期之间的时间间隔数</span><br><span class="line">DatePart       返回给定日期的指定部分</span><br><span class="line">DateSerial     返回日期的指定年、月、日</span><br><span class="line">DateValue      返回日期</span><br><span class="line">Day           返回代表一月中一天的数字</span><br><span class="line">FormatDateTime 返回以日期或时间格式化的表达式</span><br><span class="line">Hour       返回可代表一天中的小时的数字 </span><br><span class="line">IsDate       返回可指示计算表达式能否转换为日期的布尔值</span><br><span class="line">Minute       返回一个数字，代表小时的分钟 </span><br><span class="line">Month       返回一个数字，代表年的月份</span><br><span class="line">MonthName   返回指定月份的名称</span><br><span class="line">Now           返回当前的系统日期和时间</span><br><span class="line">Second       返回一个数字，代表分钟的秒</span><br><span class="line">Time       返回当前的系统时间</span><br><span class="line">Timer       返回自 12:00 AM 以来的秒数</span><br><span class="line">TimeSerial   返回特定小时、分钟和秒的时间</span><br><span class="line">TimeValue   返回时间</span><br><span class="line">Weekday       返回一个数字，代表星期的一天</span><br><span class="line">WeekdayName   返回星期中指定的一天的星期名</span><br><span class="line">Year       返回一个代表年份的数字</span><br></pre></td></tr></table></figure><h3 id="Format-函数"><a href="#Format-函数" class="headerlink" title="Format 函数"></a>Format 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FormatCurrency返回作为货币值进行格式化的表达式</span><br><span class="line">FormatDateTime返回作为日期或时间进行格式化的表达式</span><br><span class="line">FormatNumber返回作为数字进行格式化的表达式</span><br><span class="line">FormatPercent返回作为百分数进行格式化的表达式</span><br></pre></td></tr></table></figure><h3 id="Conversion-函数"><a href="#Conversion-函数" class="headerlink" title="Conversion 函数"></a>Conversion 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Asc           把字符串中的首字母转换为 ANSI 字符代码</span><br><span class="line">CBool       把表达式转换为布尔类型</span><br><span class="line">CByte        把表达式转换为 Byte 类型</span><br><span class="line">CCur       把表达式转换为货币（Currency）类型</span><br><span class="line">CDate       把有效的日期和时间表达式转换为 Date 类型</span><br><span class="line">CDbl       把表达式转换为 Double 类型</span><br><span class="line">Chr           把指定的 ANSI 字符代码转换为字符</span><br><span class="line">CInt       把表达式转换为 Int 类型</span><br><span class="line">CLng       把表达式转换为 Long 类型</span><br><span class="line">CSng       把表达式转换为 Single 类型</span><br><span class="line">CStr       把表达式转换为子类型 String 的 variant </span><br><span class="line">Hex           返回指定数字的十六进制值</span><br><span class="line">Oct           返回指定数字的八进制值</span><br></pre></td></tr></table></figure><h3 id="Array-函数"><a href="#Array-函数" class="headerlink" title="Array 函数"></a>Array 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array返回一个包含数组的变量</span><br><span class="line">Filter返回下标从零开始的数组，其中包含基于特定过滤条件的字符串数组的子集</span><br><span class="line">IsArray返回一个布尔值，可指示指定的变量是否是数组</span><br><span class="line">Join返回一个由数组中若干子字符串组成的字符串</span><br><span class="line">LBound返回指定数组维数的最小下标</span><br><span class="line">Split返回下标从0开始的一维数组，包含指定数目的子字符串</span><br><span class="line">UBound返回指定数组维数的最大下标</span><br></pre></td></tr></table></figure><h3 id="Math-函数"><a href="#Math-函数" class="headerlink" title="Math 函数"></a>Math 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Abs            返回指定数字的绝对值</span><br><span class="line">Atn            返回指定数字的反正切</span><br><span class="line">Cos            返回指定数字或角度的余弦</span><br><span class="line">Exp返回 e的幂次方</span><br><span class="line">Hex返回指定数字的十六进制值</span><br><span class="line">Int返回指定数字的整数部分</span><br><span class="line">Fix返回指定数字的整数部分</span><br><span class="line">Log返回指定数字的自然对数</span><br><span class="line">Oct返回指定数字的余弦值</span><br><span class="line">Rnd返回小于1但大于或等于0的一个随机数</span><br><span class="line">Sgn返回可指示指定的数字的符号的一个整数</span><br><span class="line">Sin返回指定数字或角度的正弦</span><br><span class="line">Sqr返回指定数字的平方根</span><br><span class="line">Tan返回指定数字或角度的正切</span><br></pre></td></tr></table></figure><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CreateObject创建指定类型对象。</span><br><span class="line">Eval计算表达式，并返回结果。</span><br><span class="line">GetLocale返回当前区域设置 ID 值。</span><br><span class="line">GetObject返回对文件中 automation 对象的引用。</span><br><span class="line">GetRef允许把 VBScript 子程序连接到页面上的一个 DHTML 事件。</span><br><span class="line">InputBox可显示对话框，用户可在其中输入文本，并&#x2F;或点击按钮，然后返回结果。</span><br><span class="line">IsEmpty返回一个布尔值，指示指定的变量是否已被初始化。</span><br><span class="line">IsNull返回一个布尔值，指示指定的变量是否包含无效数据 (Null)。</span><br><span class="line">IsNumeric返回一个布尔值，指示指定的表达式是否可作为数字来计算。</span><br><span class="line">IsObject返回一个布尔值，指示指定的表达式是否是一个 automation 对象。</span><br><span class="line">LoadPicture返回一个图片对象。仅用于32位平台。</span><br><span class="line">MsgBox显示消息框，等待用户点击按钮，并返回指示用户点击了哪个按钮的值。</span><br><span class="line">RGB返回一个表示 RGB 颜色值的数字。</span><br><span class="line">Round对数进行四舍五入。</span><br><span class="line">ScriptEngine返回使用中的脚本语言。</span><br><span class="line">ScriptEngineBuildVersion返回使用中的脚本引擎版本号。</span><br><span class="line">ScriptEngineMajorVersion返回使用中的脚本引擎的主版本号。</span><br><span class="line">ScriptEngineMinorVersion返回使用中的脚本引擎的次版本号。</span><br><span class="line">SetLocale设置地区 ID ，并返回之前的地区 ID。</span><br><span class="line">TypeName返回指定变量的子类型。</span><br><span class="line">VarType返回指示变量子类型的值。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;String-函数&quot;&gt;&lt;a href=&quot;#String-函数&quot; class=&quot;headerlink&quot; title=&quot;String 函数&quot;&gt;&lt;/a&gt;String 函数&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;InStr			返回字符串在另一字符串中首次出现的位置。检索从字符串的第一个字符开始 &amp;lt;!-- more --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;InStrRev		返回字符串在另一字符串中首次出现的位置。检索从字符串的最末字符开始&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LCase			把指定字符串转换为小写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Left			从字符串的左侧返回指定数目的字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Len				返回字符串中的字符数目&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LTrim			删除字符串左侧的空格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RTrim			删除字符串右侧的空格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Trim			删除字符串左侧和右侧的空格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mid				从字符串返回指定数目的字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Replace			使用另外一个字符串替换字符串的指定部分指定的次数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Right			返回从字符串右侧开始指定数目的字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Space			返回由指定数目的空格组成的字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StrComp			比较两个字符串，返回代表比较结果的一个值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String			返回包含指定长度的重复字符的字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StrReverse		反转字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UCase			把指定的字符串转换为大写&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>直接插入排序</title>
    <link href="http://yoursite.com/2020/01/24/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/24/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-03-23T02:51:22.744Z</updated>
    
    <content type="html"><![CDATA[<p>排序方法：将数组中所有的元素依次和前面排序好的元素进行比较，如果当前选择的元素比已排序过的元素小，则进行交换，直到所有元素都排序完毕。<br><code>直接插入排序的时间复杂度：O(n^2)</code><br>例子：有一个序列 5，9，6，4，2，8</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一趟：<span class="number">9</span>与<span class="number">5</span>比较，大于。序列为：<span class="number">5</span>，<span class="number">9</span>，<span class="number">6</span>，<span class="number">4</span>，<span class="number">2</span>，<span class="number">8</span></span><br><span class="line">第二趟：<span class="number">6</span>与前面的序列比较，大于<span class="number">5</span>，插入<span class="number">5</span>之后。序列为：<span class="number">5</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">4</span>，<span class="number">2</span>，<span class="number">8</span></span><br><span class="line">第三趟：<span class="number">4</span>与前面的序列比较，小于<span class="number">5</span>，插入<span class="number">5</span>之前。序列为：<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">2</span>，<span class="number">8</span></span><br><span class="line">第四趟：<span class="number">2</span>与前面的序列比较，小于<span class="number">4</span>，插入<span class="number">4</span>之前。序列为：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">9</span>，<span class="number">8</span></span><br><span class="line">第五趟：<span class="number">8</span>与前面的序列比较，大于<span class="number">6</span>小于<span class="number">9</span>，插入<span class="number">6</span>之后<span class="number">9</span>之前。序列为：<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,key;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">array</span>[i]&lt;<span class="built_in">array</span>[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">key=<span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">array</span>[j]&gt;key;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">array</span>[j+<span class="number">1</span>]=<span class="built_in">array</span>[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[j+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序方法：将数组中所有的元素依次和前面排序好的元素进行比较，如果当前选择的元素比已排序过的元素小，则进行交换，直到所有元素都排序完毕。&lt;br&gt;&lt;code&gt;直接插入排序的时间复杂度：O(n^2)&lt;/code&gt;&lt;br&gt;例子：有一个序列 5，9，6，4，2，8&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树、森林与二叉树的转换</title>
    <link href="http://yoursite.com/2020/01/22/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/01/22/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-03-23T02:55:49.939Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-树的概念"><a href="#1-树的概念" class="headerlink" title="1. 树的概念"></a>1. 树的概念</h5><p>树是 n（n≥0）个有限数据元素的集合。当n＝0 时，称这棵树为空树。在一棵非空树中：<br>（1）有一个特殊的数据元素称为树的根结点，根结点没有前驱结点。<br>（2）若n&gt;1，除根结点之外的其余数据元素被分成m（m&gt;0）个互不相交的集合T1，T2，…，Tm，其中每一个集合Ti（1≤i≤m）本身又是一棵树。树T1，T2，…，Tm 称为这个根结点的子树。</p><a id="more"></a> <p>树的特点：<br>（1）树的根结点没有前驱结点，除根结点之外的所有结点有且只有一个前驱结点。<br>（2）树中所有结点可以有零个或多个后继结点。</p><h5 id="2-树转换为二叉树"><a href="#2-树转换为二叉树" class="headerlink" title="2. 树转换为二叉树"></a>2. 树转换为二叉树</h5><p>方法：<br>（1）树中所有相邻兄弟之间加一条连线。<br>（2）对树中的每个结点，只保留它与第一个孩子结点之间的连线，删去它与其它孩子结点之间的连线。<br>（3）以树的根结点为轴心，将整棵树顺时针转动一定的角度，使之结构层次分明。</p><h5 id="3-森林转换为二叉树"><a href="#3-森林转换为二叉树" class="headerlink" title="3. 森林转换为二叉树"></a>3. 森林转换为二叉树</h5><p>森林是若干棵树的集合，只要将森林中各棵树的根视为兄弟，每棵树又可以用二叉树表示。<br>方法：<br>（1）将森林中的每棵树转换成相应的二叉树。<br>（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连起来后，此时所得到的二叉树就是由森林转换得到的二叉树。</p><h5 id="4-二叉树转换为树和森林"><a href="#4-二叉树转换为树和森林" class="headerlink" title="4. 二叉树转换为树和森林"></a>4. 二叉树转换为树和森林</h5><p>树和森林都可以转换为二叉树，二者不同的是树转换成的二叉树，其根结点无右分支，而森林转换后的二叉树，其根结点有右分支。可以依据二叉树的根结点有无<code>右分支</code>，将一棵二叉树还原为树或森林，<br>方法如下：<br>（1）若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子都与该结点的双亲结点用线连起来；<br>（2）删去原二叉树中所有的双亲结点与右孩子结点的连线；<br>（3）整理由（1）、（2）两步所得到的树或森林，使之结构层次分明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-树的概念&quot;&gt;&lt;a href=&quot;#1-树的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 树的概念&quot;&gt;&lt;/a&gt;1. 树的概念&lt;/h5&gt;&lt;p&gt;树是 n（n≥0）个有限数据元素的集合。当n＝0 时，称这棵树为空树。在一棵非空树中：&lt;br&gt;（1）有一个特殊的数据元素称为树的根结点，根结点没有前驱结点。&lt;br&gt;（2）若n&amp;gt;1，除根结点之外的其余数据元素被分成m（m&amp;gt;0）个互不相交的集合T1，T2，…，Tm，其中每一个集合Ti（1≤i≤m）本身又是一棵树。树T1，T2，…，Tm 称为这个根结点的子树。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树（最优二叉树）</title>
    <link href="http://yoursite.com/2020/01/20/%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91)/"/>
    <id>http://yoursite.com/2020/01/20/%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91)/</id>
    <published>2020-01-19T16:00:00.000Z</published>
    <updated>2020-03-22T12:49:37.845Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1．哈夫曼树的概念"><a href="#1．哈夫曼树的概念" class="headerlink" title="1．哈夫曼树的概念"></a>1．哈夫曼树的概念</h5><p>最优二叉树，也称哈夫曼（Haffman）树，是指对于一组带有确定权值的叶结点，构造的具有最小带权路径长度的二叉树。</p><h5 id="2-二叉树的带权路径长度"><a href="#2-二叉树的带权路径长度" class="headerlink" title="2 . 二叉树的带权路径长度"></a>2 . 二叉树的带权路径长度</h5><p>相同权值的一组叶子结点所构成的二叉树有不同的形态和不同的带权路径长度。根据哈夫曼树的定义，一棵二叉树要使其WPL 值最小，必须使权值越大的叶结点越靠近根结点，而权值越小的叶结点越远离根结点。</p><a id="more"></a><p>方法：<br>（1）由给定的 n 个权值{W1，W2，…，Wn}构造n 棵只有一个叶结点的二叉树，从而得到一个二叉树的集合F＝{T1，T2，…，Tn}；<br>（2）在F 中选取根结点的权值最小和次小的两棵二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根结点的权值为其左、右子树根结点权值之和；<br>（3）在集合F 中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F 中；<br>（4）重复（2）（3）两步，当F 中只剩下一棵二叉树时，这棵二叉树便是所要建立的哈夫曼树。</p><h5 id="3-哈夫曼树的构造算法"><a href="#3-哈夫曼树的构造算法" class="headerlink" title="3 . 哈夫曼树的构造算法"></a>3 . 哈夫曼树的构造算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVALUE 10000 <span class="comment">/*定义最大权值*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEAF 30 <span class="comment">/*定义哈夫曼树中叶子结点个数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNODE MAXLEAF*2-1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">int</span> parent;</span><br><span class="line"><span class="keyword">int</span> lchild;</span><br><span class="line"><span class="keyword">int</span> rchild;</span><br><span class="line">&#125;HNodeType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HaffmanTree</span><span class="params">(HNodeType HuffNode [ ])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*哈夫曼树的构造算法*/</span></span><br><span class="line"><span class="keyword">int</span> i,j,m1,m2,x1,x2,n;</span><br><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;n); <span class="comment">/*输入叶子结点个数*/</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++) <span class="comment">/*数组HuffNode[ ]初始化*/</span></span><br><span class="line">&#123; HuffNode[i].weight=<span class="number">0</span>;</span><br><span class="line">HuffNode[i].parent=<span class="number">-1</span>;</span><br><span class="line">HuffNode[i].lchild=<span class="number">-1</span>;</span><br><span class="line">HuffNode[i].rchild=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;HuffNode[i].weight); <span class="comment">/*输入n 个叶子结点的权值*/</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) <span class="comment">/*构造哈夫曼树*/</span></span><br><span class="line">&#123; </span><br><span class="line">m1=m2=MAXVALUE;</span><br><span class="line">x1=x2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n+i;j++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (HuffNode[j].weight&lt;m1 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">&#123; </span><br><span class="line">m2=m1; x2=x1;</span><br><span class="line">m1=HuffNode[j].weight; x1=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight&lt;m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">&#123; </span><br><span class="line">m2=HuffNode[j].weight;</span><br><span class="line">x2=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将找出的两棵子树合并为一棵子树*/</span></span><br><span class="line">HuffNode[x1].parent=n+i; HuffNode[x2].parent=n+i;</span><br><span class="line">HuffNode[n+i].weight= HuffNode[x1].weight+HuffNode[x2].weight;</span><br><span class="line">HuffNode[n+i].lchild=x1; HuffNode[n+i].rchild=x2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-哈夫曼编码算法"><a href="#4-哈夫曼编码算法" class="headerlink" title="4. 哈夫曼编码算法"></a>4. 哈夫曼编码算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBIT 10 <span class="comment">/*定义哈夫曼编码的最大长度*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> bit[MAXBIT];</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line">&#125;HCodeType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HaffmanCode</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/*生成哈夫曼编码*/</span></span><br><span class="line">HNodeType HuffNode[MAXNODE];</span><br><span class="line">HCodeType HuffCode[MAXLEAF],cd;</span><br><span class="line"><span class="keyword">int</span> i,j, c,p;</span><br><span class="line">HuffmanTree (HuffNode ); <span class="comment">/*建立哈夫曼树*/</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">/*求每个叶子结点的哈夫曼编码*/</span></span><br><span class="line">&#123; </span><br><span class="line">cd.start=n<span class="number">-1</span>; c=i;</span><br><span class="line">p=HuffNode[c].parent;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="number">0</span>) <span class="comment">/*由叶结点向上直到树根*/</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (HuffNode[p].lchild==c) cd.bit[cd.start]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> cd.bit[cd.start]=<span class="number">1</span>;</span><br><span class="line">cd.start--; c=p;</span><br><span class="line">p=HuffNode[c].parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j=cd.start+<span class="number">1</span>;j&lt;n;j++) <span class="comment">/*保存求出的每个叶结点的哈夫曼编码和编码的起始位*/</span></span><br><span class="line">HuffCode[i].bit[j]=cd.bit[j];</span><br><span class="line">HuffCode[i].start=cd.start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">/*输出每个叶子结点的哈夫曼编码*/</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">for</span> (j=HuffCode[i].start+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line"><span class="built_in">printf</span>(“%ld”,HuffCode[i].bit[j]);</span><br><span class="line"><span class="built_in">printf</span>(“\n”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1．哈夫曼树的概念&quot;&gt;&lt;a href=&quot;#1．哈夫曼树的概念&quot; class=&quot;headerlink&quot; title=&quot;1．哈夫曼树的概念&quot;&gt;&lt;/a&gt;1．哈夫曼树的概念&lt;/h5&gt;&lt;p&gt;最优二叉树，也称哈夫曼（Haffman）树，是指对于一组带有确定权值的叶结点，构造的具有最小带权路径长度的二叉树。&lt;/p&gt;
&lt;h5 id=&quot;2-二叉树的带权路径长度&quot;&gt;&lt;a href=&quot;#2-二叉树的带权路径长度&quot; class=&quot;headerlink&quot; title=&quot;2 . 二叉树的带权路径长度&quot;&gt;&lt;/a&gt;2 . 二叉树的带权路径长度&lt;/h5&gt;&lt;p&gt;相同权值的一组叶子结点所构成的二叉树有不同的形态和不同的带权路径长度。根据哈夫曼树的定义，一棵二叉树要使其WPL 值最小，必须使权值越大的叶结点越靠近根结点，而权值越小的叶结点越远离根结点。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="http://yoursite.com/2020/01/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2020/01/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2020-01-17T16:00:00.000Z</published>
    <updated>2020-03-23T02:57:13.002Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的遍历是指按照某种顺序访问二叉树中的每个结点，使每个结点被访问一次且仅被访问一次。<br>一棵树由根结点、根结点的左子树和根结点的右子树三部分组成。只要依次遍历这三部分，就可以遍历整个二叉树。<br>若以D、L、R 分别表示访问根结点、遍历根结点的左子树、遍历根结点的右子树，则二叉树的遍历三种方式：DLR（先序遍历）、LDR（中序遍历）和LRD（后序遍历）。<a id="more"></a> </p><h5 id="1．先序遍历（DLR）"><a href="#1．先序遍历（DLR）" class="headerlink" title="1．先序遍历（DLR）"></a>1．先序遍历（DLR）</h5><p>先序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1）访问根结点；<br>（2）先序遍历根结点的左子树；<br>（3）先序遍历根结点的右子树。<br>递归算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PreOrder（BiTree bt）</span><br><span class="line"><span class="comment">/*先序遍历二叉树bt*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span>; <span class="comment">/*递归调用的结束条件*/</span></span><br><span class="line">Visite（bt-&gt;data）; <span class="comment">/*访问结点的数据域*/</span></span><br><span class="line">PreOrder（bt-&gt;lchild）; <span class="comment">/*先序递归遍历bt 的左子树*/</span></span><br><span class="line">PreOrder（bt-&gt;rchild）; <span class="comment">/*先序递归遍历bt 的右子树*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2．中序遍历（LDR）"><a href="#2．中序遍历（LDR）" class="headerlink" title="2．中序遍历（LDR）"></a>2．中序遍历（LDR）</h5><p>中序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1）中序遍历根结点的左子树；<br>（2）访问根结点；<br>（3）中序遍历根结点的右子树。</p><p>递归算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InOrder（BiTree bt）</span><br><span class="line"><span class="comment">/*中序遍历二叉树bt*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span>; <span class="comment">/*递归调用的结束条件*/</span></span><br><span class="line">InOrder（bt-&gt;lchild）; <span class="comment">/*中序递归遍历bt 的左子树*/</span></span><br><span class="line">Visite（bt-&gt;data）; <span class="comment">/*访问结点的数据域*/</span></span><br><span class="line">InOrder（bt-&gt;rchild）; <span class="comment">/*中序递归遍历bt 的右子树*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3．后序遍历（LRD）"><a href="#3．后序遍历（LRD）" class="headerlink" title="3．后序遍历（LRD）"></a>3．后序遍历（LRD）</h5><p>后序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1）后序遍历根结点的左子树；<br>（2）后序遍历根结点的右子树。<br>（3）访问根结点；<br>递归算法：<br>void PostOrder（BiTree bt）<br>/<em>后序遍历二叉树bt</em>/</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span>; <span class="comment">/*递归调用的结束条件*/</span></span><br><span class="line">PostOrder（bt-&gt;lchild）; <span class="comment">/*后序递归遍历bt 的左子树*/</span></span><br><span class="line">PostOrder（bt-&gt;rchild）; <span class="comment">/*后序递归遍历bt 的右子树*/</span></span><br><span class="line">Visite（bt-&gt;data）; <span class="comment">/*访问结点的数据域*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的遍历是指按照某种顺序访问二叉树中的每个结点，使每个结点被访问一次且仅被访问一次。&lt;br&gt;一棵树由根结点、根结点的左子树和根结点的右子树三部分组成。只要依次遍历这三部分，就可以遍历整个二叉树。&lt;br&gt;若以D、L、R 分别表示访问根结点、遍历根结点的左子树、遍历根结点的右子树，则二叉树的遍历三种方式：DLR（先序遍历）、LDR（中序遍历）和LRD（后序遍历）。
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-01-12T16:00:00.000Z</published>
    <updated>2020-03-22T13:03:09.736Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-二叉树的概念"><a href="#1-二叉树的概念" class="headerlink" title="1. 二叉树的概念"></a>1. 二叉树的概念</h5><p>二叉树是个有限元素的集合，由一个根元素及两个不相交的、左子树和右子树组成二叉树。该集合为空时称做空二叉树。在二叉树中，一个元素也称作一个结点。</p><a id="more"></a><h5 id="2-二叉树的相关概念"><a href="#2-二叉树的相关概念" class="headerlink" title="2. 二叉树的相关概念"></a>2. 二叉树的相关概念</h5><ol><li>结点的度：结点所拥有的子树的个数称为该结点的度。</li><li>叶结点：度为0 的结点称为叶结点。</li><li>分枝结点：度不为0 的结点称为分支结点。一棵树的结点除叶结点外，其余的都是分支结点。</li><li>路径、路径长度。如果一棵树的一串结点n1,n2,…,nk 有如下关系：结点ni 是ni+1的父结点（1≤i&lt;k），就把n1,n2,…,nk 称为一条由n1 至nk 的路径。这条路径的长度是<code>k-1</code>。</li><li>树的深度：树中所有结点的最大层数称为树的深度。</li><li>树的度：树中各结点度的最大值称为该树的度。</li><li>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上。</li><li>完全二叉树：一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。<code>完全二叉树的特点是：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。</code><h5 id="3-二叉树的主要性质"><a href="#3-二叉树的主要性质" class="headerlink" title="3.  二叉树的主要性质"></a>3.  二叉树的主要性质</h5>性质1：一棵非空二叉树的第i 层上最多有<code>2i-1</code> 个结点（i≥1）。</li></ol><p>性质2 ：一棵深度为k 的二叉树中，最多具有<code>2k－1</code> 个结点。</p><p>性质3 ：对于一棵非空的二叉树，如果叶子结点数为n0，度数为2 的结点数为n2，则有：<code>n0＝n2＋1</code>。</p><p>性质4 具有n 个结点的完全二叉树的深度 k 为 <code>[log2n]+1</code>。</p><p>性质5 ：对于具有n 个结点的完全二叉树，如果按照从上至下和从左到右的顺序对二叉树中的所有结点从1 开始顺序编号，则对于任意的序号为i 的结点，有：</p><ul><li>如果i&gt;1，则序号为i 的结点的双亲结点的序号为i/2(“/”表示整除)；如果i＝1，则序号为i 的结点是根结点，无双亲结点。</li><li>如果2i≤n，则序号为i 的结点的左孩子结点的序号为2i；如果2i&gt;n，则序号为i 的结点无左孩子。</li><li>如果2i＋1≤n，则序号为i 的结点的右孩子结点的序号为2i＋1；如果2i＋1&gt;n，则序号为i 的结点无右孩子。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-二叉树的概念&quot;&gt;&lt;a href=&quot;#1-二叉树的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 二叉树的概念&quot;&gt;&lt;/a&gt;1. 二叉树的概念&lt;/h5&gt;&lt;p&gt;二叉树是个有限元素的集合，由一个根元素及两个不相交的、左子树和右子树组成二叉树。该集合为空时称做空二叉树。在二叉树中，一个元素也称作一个结点。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——队列</title>
    <link href="http://yoursite.com/2020/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/</id>
    <published>2020-01-10T16:00:00.000Z</published>
    <updated>2020-03-23T02:57:56.966Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-队列的定义"><a href="#1-队列的定义" class="headerlink" title="1. 队列的定义"></a>1. 队列的定义</h4><p>队列是指插入在表一端进行，而删除在表的另一端进行。允许插入的一端叫队尾，允许删除的一端叫队头。其特点是先进先出。</p><h4 id="2-基本运算"><a href="#2-基本运算" class="headerlink" title="2. 基本运算"></a>2. 基本运算</h4><p>2.1、队列初始化：<code>Init_Queue(q)</code>， 构造一个空队。初始条件： 队q 不存在。</p><p>2.2、入队： <code>In_Queue(q,x)</code>，对已存在的队列，插入一个元素 x 到队尾，队发生变化。初始条件是 队 q 存在。</p><a id="more"></a><p>2.3、出队： <code>Out_Queue(q,x)</code>， 删除队首元素，并返回其值，队发生变化。初始条件是队q 存在且非空。</p><p>2.4、 读队头元素：<code>Front_Queue(q,x)</code>读队头元素，并返回其值，队不变。初始条件是队q 存在且非空。</p><p>2.5、判队空：<code>Empty_Queue(q)</code>，若q 为空队则返回为1，否则返回为0。初始条件是队 q 存在。#### 3. 队列的存储实现及运算实现<br><strong>3.1、顺序队</strong><br>顺序存储的队称为顺序队。<br><strong>**</strong>顺序队的类型定义：<strong>**</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define MAXSIZE 1024 &#x2F;*队列的最大容量*&#x2F;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;datatype data[MAXSIZE]; &#x2F;*队员的存储空间*&#x2F;</span><br><span class="line">int rear,front; &#x2F;*队头队尾指针*&#x2F;</span><br><span class="line">&#125;SeQueue;</span><br></pre></td></tr></table></figure><p>解决<code>假溢出</code>的方法之一是将队列的数据区data[0..MAXSIZE-1]看成头尾相接的循环结构，头尾指针的关系不变，将其称为“循环队”。<br>队空情况下也有：front==rear。<br>解决方法有：设一个存储队中元素个数的变量如 num，当<code>num==0</code> 时队空，当<code>num==MAXSIZE</code> 时为队满。<br>循环队列的类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">datatype data[MAXSIZE]; <span class="comment">/*数据的存储区*/</span></span><br><span class="line"><span class="keyword">int</span> front,rear; <span class="comment">/*队头队尾指针*/</span></span><br><span class="line"><span class="keyword">int</span> num; <span class="comment">/*队中元素的个数*/</span></span><br><span class="line">&#125;c_SeQueue; <span class="comment">/*循环队*/</span></span><br></pre></td></tr></table></figure><p>基本运算：</p><ul><li>1、队初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">c_SeQueue* <span class="title">Init_SeQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">q=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(c_SeQueue));</span><br><span class="line">q-&gt;front=q-&gt;rear=MAXSIZE<span class="number">-1</span>;</span><br><span class="line">q-&gt;num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、 入队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">In_SeQueue</span> <span class="params">( c_SeQueue *q , datatype x)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (num==MAXSIZE)</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">printf</span>(＂队满＂);</span><br><span class="line"><span class="keyword">return</span> –<span class="number">1</span>; <span class="comment">/*队满不能入队*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">q-&gt;rear=(q-&gt;rear+<span class="number">1</span>) % MAXSIZE;</span><br><span class="line">q-&gt;data[q-&gt;rear]=x;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/*入队完成*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、出队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Out_SeQueue</span> <span class="params">(c_SeQueue *q , datatype *x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">printf</span>(＂队空＂)；</span><br><span class="line"><span class="keyword">return</span> –<span class="number">1</span>; <span class="comment">/*队空不能出队*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">q-&gt;front=(q-&gt;front+<span class="number">1</span>) % MAXSIZE;</span><br><span class="line">*x=q-&gt;data[q-&gt;front]; <span class="comment">/*读出队头元素*/</span></span><br><span class="line">num--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/*出队完成*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4、判队空</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty_SeQueue</span><span class="params">(c_SeQueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (num==<span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2． 链队</strong><br>链式存储的队称为链队。用单链表来实现链队。<br>链队的基本运算如下：</p><ul><li>1、创建一个带头结点的空队：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LQueue *<span class="title">Init_LQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">LQueue *q,*p;</span><br><span class="line">q=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LQueue)); <span class="comment">/*申请头尾指针结点*/</span></span><br><span class="line">p=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode)); <span class="comment">/*申请链队头结点*/</span></span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>; q-&gt;front=q-&gt;rear=p;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、入队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">In_LQueue</span><span class="params">(LQueue *q , datatype x)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">QNode *p;</span><br><span class="line">p=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNnode)); <span class="comment">/*申请新结点*/</span></span><br><span class="line">p-&gt;data=x; p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">q-&gt;rear-&gt;next=p;</span><br><span class="line">q-&gt;rear=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、判队空</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty_LQueue</span><span class="params">( LQueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (q-&gt;front==q-&gt;rear) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4、出队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Out_LQueue</span><span class="params">(LQueue *q , datatype *x)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">QNnode *p;</span><br><span class="line"><span class="keyword">if</span> (Empty_LQueue(q) )</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">printf</span> (＂队空＂)； <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/*队空，出队失败*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">p=q-&gt;front-&gt;neat;</span><br><span class="line">q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">*x=p-&gt;data;<span class="comment">/*队头元素放x 中*/</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">if</span> (q-&gt;front-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">q-&gt;rear=q-&gt;front;</span><br><span class="line"><span class="comment">/*只有一个元素时，出队后队空，此时还要要修改队尾指针参考图3.16(c)*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-队列的定义&quot;&gt;&lt;a href=&quot;#1-队列的定义&quot; class=&quot;headerlink&quot; title=&quot;1. 队列的定义&quot;&gt;&lt;/a&gt;1. 队列的定义&lt;/h4&gt;&lt;p&gt;队列是指插入在表一端进行，而删除在表的另一端进行。允许插入的一端叫队尾，允许删除的一端叫队头。其特点是先进先出。&lt;/p&gt;
&lt;h4 id=&quot;2-基本运算&quot;&gt;&lt;a href=&quot;#2-基本运算&quot; class=&quot;headerlink&quot; title=&quot;2. 基本运算&quot;&gt;&lt;/a&gt;2. 基本运算&lt;/h4&gt;&lt;p&gt;2.1、队列初始化：&lt;code&gt;Init_Queue(q)&lt;/code&gt;， 构造一个空队。初始条件： 队q 不存在。&lt;/p&gt;
&lt;p&gt;2.2、入队： &lt;code&gt;In_Queue(q,x)&lt;/code&gt;，对已存在的队列，插入一个元素 x 到队尾，队发生变化。初始条件是 队 q 存在。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——栈</title>
    <link href="http://yoursite.com/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/"/>
    <id>http://yoursite.com/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/</id>
    <published>2020-01-07T16:00:00.000Z</published>
    <updated>2020-03-22T09:02:54.322Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、栈的定义"><a href="#1、栈的定义" class="headerlink" title="1、栈的定义"></a>1、栈的定义</h5><p>栈是限制在表的一端进行插入和删除的线性表。允许插入、删除的这一端称为栈顶，另一个固定端称为栈底。当表中没有元素时称为空栈，其特点是后进先出。</p><a id="more"></a><h5 id="2、栈的基本运算"><a href="#2、栈的基本运算" class="headerlink" title="2、栈的基本运算"></a>2、栈的基本运算</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈初始化：Init_Stack(s)</span><br><span class="line">初始条件：栈 s 不存在</span><br><span class="line">操作结果：构造了一个空栈。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判栈空：Empty_Stack(s)</span><br><span class="line">初始条件：栈 s 已存在</span><br><span class="line">操作结果：若 s 为空栈返回为1，否则返回为0。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">入栈： Push_Stack(s，x)</span><br><span class="line">初始条件：栈 s 已存在</span><br><span class="line">操作结果：在栈 s 的顶部插入一个新元素x， x 成为新的栈顶元素。栈发生变化。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">出栈：Pop_Stack(s)</span><br><span class="line">初始条件：栈 s 存在且非空</span><br><span class="line">操作结果：栈 s 的顶部元素从栈中删除，栈中少了一个元素。栈发生变化。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读栈顶元素：Top_Stack(s)</span><br><span class="line">初始条件：栈 s 存在且非空</span><br><span class="line">操作结果：栈顶元素作为结果返回，栈不变。</span><br></pre></td></tr></table></figure><h5 id="3、栈的存储实现和运算实现"><a href="#3、栈的存储实现和运算实现" class="headerlink" title="3、栈的存储实现和运算实现"></a>3、栈的存储实现和运算实现</h5><p><strong>1． 顺序栈</strong></p><p>顺序栈指的是利用顺序存储方式实现的栈。栈中的数据元素用一个预设的足够长度的一维数组来实现，栈底位置可以设置在数组的任一个端点，而栈顶是随着插入和删除而变化的，用一个int top 来作为栈顶的指针，指明当前栈顶的位置，同样将data 和top 封装在一个结构中。<br>顺序栈的类型描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 1024</span><br><span class="line">typedef struct</span><br><span class="line">&#123;datatype data[MAXSIZE];</span><br><span class="line">int top;</span><br><span class="line">&#125;SeqStack</span><br></pre></td></tr></table></figure><p>定义一个指向顺序栈的指针：<code>SeqStack *s;</code><br>一般把 0 下标端设为栈底，这样空栈时栈顶指针top=-1；入栈时，栈顶指针加１，即s-&gt;top++；出栈时，栈顶指针减１，即s-&gt;top–。</p><ul><li>栈初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SeqStack *Init_SeqStack()</span><br><span class="line">&#123; </span><br><span class="line">SeqStack *s;</span><br><span class="line">s&#x3D;malloc(sizeof(SeqStack));</span><br><span class="line">s-&gt;top&#x3D; -1; return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>判空栈</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Empty_SeqStack(SeqStack *s)</span><br><span class="line">&#123; </span><br><span class="line">if (s-&gt;top&#x3D; &#x3D; -1) </span><br><span class="line">return 1;</span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>入栈<br>int Push_SeqStack (SeqStack <em>s, datatype x)<br>{<br>if (s-&gt;top= =MAXSIZE-1)<br>return 0; /*栈满不能入栈</em>/<br>else {<br>s-&gt;top++;<br>s-&gt;data[s-&gt;top]=x;<br>return 1;<br>}<br>}</p></li><li><p>出栈</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int Pop_SeqStack(SeqStack *s, datatype *x)</span><br><span class="line">&#123;</span><br><span class="line"> if (Empty_SeqStack ( s ) ) </span><br><span class="line"> return 0; &#x2F;*栈空不能出栈*&#x2F;</span><br><span class="line">else &#123; </span><br><span class="line">*x&#x3D;s-&gt;data[s-&gt;top];</span><br><span class="line">s-&gt;top--; </span><br><span class="line">return 1; </span><br><span class="line">&#125; &#x2F;*栈顶元素存入*x，返回*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>取栈顶元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">datatype Top_SeqStack(SeqStack *s)</span><br><span class="line">&#123; </span><br><span class="line">if ( Empty_SeqStack ( s ) ) </span><br><span class="line">return 0; &#x2F;*栈空*&#x2F;</span><br><span class="line">else </span><br><span class="line">return (s-&gt;data[s-&gt;top] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于顺序栈，入栈时，首先判栈是否满了，栈满的条件为：s-&gt;top= =MAXSIZE-1，栈满时，不能入栈；否则出现空间溢出，引起错误。<br>出栈和读栈顶元素操作，先判栈是否为空，为空时不能操作，否则产生错误。</p><p><strong>2． 链栈</strong></p><p>链栈指的是用链式存储结构实现的栈。<br>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node</span><br><span class="line">&#123; </span><br><span class="line">datatype data;</span><br><span class="line">struct node *next;</span><br><span class="line">&#125;StackNode，* LinkStack;</span><br></pre></td></tr></table></figure><p>top 为栈顶指针，栈中的主要运算是在栈顶插入、删除，在链表的头部做栈顶是最方便的。</p><p>链栈基本操作的实现如下：</p><ul><li>栈初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkStack Init_LinkStack（）</span><br><span class="line">&#123; </span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>判栈空</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Empty_LinkStack（LinkStack top ）</span><br><span class="line">&#123; </span><br><span class="line">if（top&#x3D;&#x3D;-1） </span><br><span class="line">return 1;</span><br><span class="line">else </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>入栈</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkStack Push_LinkStack（LinkStack top, datatype x）</span><br><span class="line">&#123; </span><br><span class="line">StackNode *s;</span><br><span class="line">s&#x3D;malloc（sizeof（StackNode））;</span><br><span class="line">s-&gt;data&#x3D;x;</span><br><span class="line">s-&gt;next&#x3D;top;</span><br><span class="line">top&#x3D;s;</span><br><span class="line">return top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出栈</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkStack Pop_LinkStack (LinkStack top, datatype *x)</span><br><span class="line">&#123; </span><br><span class="line">StackNode *p;</span><br><span class="line">if （top&#x3D; &#x3D;NULL） </span><br><span class="line">return NULL;</span><br><span class="line">else &#123; </span><br><span class="line">*x &#x3D; top-&gt;data;</span><br><span class="line">p &#x3D; top;</span><br><span class="line">top &#x3D; top-&gt;next;</span><br><span class="line">free (p);</span><br><span class="line">return top;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1、栈的定义&quot;&gt;&lt;a href=&quot;#1、栈的定义&quot; class=&quot;headerlink&quot; title=&quot;1、栈的定义&quot;&gt;&lt;/a&gt;1、栈的定义&lt;/h5&gt;&lt;p&gt;栈是限制在表的一端进行插入和删除的线性表。允许插入、删除的这一端称为栈顶，另一个固定端称为栈底。当表中没有元素时称为空栈，其特点是后进先出。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
